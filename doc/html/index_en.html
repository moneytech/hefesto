<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Untitled.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="a-*build-system*-called-hefesto"><a name="a-*build-system*-called-hefesto" href="#a-*build-system*-called-hefesto"></a>A <em>build system</em> called Hefesto</h1><p><em>by Rafael Santiago</em></p><hr class="section"><p><strong>Abstract</strong>: This document brings some information related with this project. My motivations. General details about the <code>HSL</code>. Project decisions. Crazy digressions and ideias that could contradict yours, if you are a sensible soul… :-)</p><hr class="section"><h2 id="hefesto-who?"><a name="hefesto-who?" href="#hefesto-who?"></a>Hefesto who?</h2><p><code>Hefesto</code> is a non-orthodox <em>build system</em> that conservative people will hate. The main concept in this application is to make clearer anything that is being performed related with <em>build tasks</em> on your software project.</p><h2 id="the-motivation"><a name="the-motivation" href="#the-motivation"></a>The motivation</h2><p><em>Hefesto</em> is a <em>build system</em> that I wrote seeking answers for some questions that I always made about <em>build systems</em>:</p><ul>
<li>Why <em>build systems</em> abuse on the declarative Languages usage?</li><li>Why in general the syntax of these Languages are awful?</li><li>Why a developer can not sit down and programming the <em>build</em> instead of writing messy statements?</li><li>Why to do it is necessary to put a bunch of trinket together?</li><li>Is it ugly to look for clarity?</li><li>Why to adopt the snail-philosophy to call any place home?</li></ul><p>Maybe during your reading you will figure out that <em>Hefesto</em> is not a <em>build system</em> but more about what a <em>build system</em> in the essence is or at least should be.</p><h2 id="automate-or-die!"><a name="automate-or-die!" href="#automate-or-die!"></a>Automate or die!</h2><p>I develop <em>software</em> and I like to automate things. I think any repetitive task is a torture just because I could be doing other things insted of repeating old things.</p><p>Refreshing my last statement: I develop <em>software</em> and I like to think about new things all the time and as result I <em>need</em> to automate in order to enjoy this precious time.</p><p>I think that the most basic autotation in a software project is his <em>big-bang</em>. In other words his <em>build</em>.</p><p>We have got countless ways to automate <em>build</em>. From <em>shell scripts</em> and <em>arcanas batch files</em> to <em>Makefiles</em>, <em>Jamfiles</em> and so on.</p><p>During the years that I have been programming I used all kinds of those among others. Personally, I have never completely assisted by none of them.</p><p>Here are some aspects that took me gave up about them and only use these tools when the situation (project) enforces me:</p><ul>
<li>Rather “symbolic languages”</li><li>Whitespace-like language</li><li>The application not keep all your power (capabilities) when we change the platform</li><li>Sometimes we need to install a bunch of others things in order to maintain the build-tool’s capabilities and have the work done</li><li>The documentation is a mess</li><li>A mix of Languages without necessity</li><li>The usage is rather confuse which sometimes can involve two “sub-tools” even more (again: to have the work done)</li><li>Visual tools based on XML what is awful talking about versioning and take some diffs. The things get worse when the XML is automatically generated</li><li>Need to adapt (decrease) your understanding of clearness and quality to accept the build-tool’s limitations</li></ul><h1 id="how-hefesto-works"><a name="how-hefesto-works" href="#how-hefesto-works"></a>How Hefesto works</h1><p><code>Hefesto</code> considers that your are a programmer which have a consistent knowledge about the compilers that you are using. If you judge yourself a sniper<br>but until now only have been using paintball guns… it is better to stop reading this.</p><p>This tool is based on automating the build process essence and this means compilation and linking in several cases. For this kind of automation<br>is used the dsl implemented called <code>HSL</code> what means <code>H</code>efesto <code>S</code>cript <code>L</code>anguage.</p><p>The most of build systems have a magical file that existing in a specific place of the project tree.. “sheebang!” … Here in <code>Hefesto</code> not…<br>The <code>Hefesto</code> allows you to call this magical file with the name that you want to. I like to call mine “Forgefiles”.</p><p>Here is a sample of a Forgefile for a C library:</p><pre><code data-origin="<pre><code># Comment-sample: Forgefile.hsl...

include ~/toolsets/gcc/gcc-lib.hsl

var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project here : toolset &quot;gcc-c-lib&quot; : $sources, $includes, $cflags, $libraries, $ldflags, &quot;libhere.a&quot;;

here.prologue() {
    $sources.ls(&quot;.*\\.c@@bodyquot;);
}
</code></pre>"># Comment-sample: Forgefile.hsl...

include ~/toolsets/gcc/gcc-lib.hsl

var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project here : toolset "gcc-c-lib" : $sources, $includes, $cflags, $libraries, $ldflags, "libhere.a";

here.prologue() {
    $sources.ls(".*\\.c$");
}
</code></pre><p>In the sample above you can see some HSL statements and it continues inside the “toolset”. The toolset can be understood as a set or<br>collection of HSL code which automates the essence of a build process. The knowledge base of “how to build a library in language X”,<br>“how to build a application in language Y”, etc.</p><p>Still talking about the sample, note that after the commentary is done a suggestive inclusion. There we are infusing in that Forgefile<br>a previous knowledge base of how to build a C library using GCC.</p><p>Following this, a thing that several people hates with passion. You need to declare everything (I said everything) that you going<br>to use. Something like: “Hey guys! I need to use this so excuse me, right?”.</p><p>I think it is a good thing to do (talking about programming languages design) because this feature jumps from the device<br>to the programmers’ mind so at the moment of the declaration the user will think better about the variable’s implications.</p><p>Backing to the code, these declared variables are used by the forge function (the entry-point to the more internal parts of the build).</p><p>After these declarations we have got the project declaration. Saying:</p><blockquote>
<p>“This project is called “here” it is an C-library that will be compiled with GCC. Follows the parameters in the<br>order that the build engine for this kind of thing expects.”</p>
</blockquote><p>The related toolset expects a source code list, a include directory list, a list containing the compiler flags, a library directory list,<br>a linker flag list and finally a name which will be used for creating the target library.</p><p>Some build systems do not provide ways for scanning the codes which will be processed. Some others allow the user read the source code list from anywhere.</p><p>The Hefesto is provides one simple but generical way. Sometimes there are several sub-tasks for being executed besides just compile the project. When<br>a project is created under Hefesto, three entry points are created together with this project: preloading, prologue e epilogue.</p><p>Take a look at the Table 1 for knowing more about these entry points, specially when they are hitted during the process. The basic idea here is:<br>if exists defined code inside these entry points, on a specific moment the defined code will be executed.</p><p>Table 1: The project’s stages</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Project entry-point</strong></th>
<th style="text-align:center"><strong>Executes</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>preloading</code></td>
<td style="text-align:center">Before loading the toolset</td>
</tr>
<tr>
<td style="text-align:center"><code>prologue</code></td>
<td style="text-align:center">Before starting the forge</td>
</tr>
<tr>
<td style="text-align:center"><code>epilogue</code></td>
<td style="text-align:center">After finishing the forge</td>
</tr>
</tbody>
</table><p>By now let’s forget about the <code>preloading</code> and <code>epilogue</code> stages. For collecting the source code <em>file paths</em> we can use the entry point <code>prologue</code>.</p><pre><code data-origin="<pre><code>    here.prologue() {
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    here.prologue() {
        $sources.ls(".*\\.c$");
    }
</code></pre><p>Do not worry about the <code>.ls()</code>… On further sections when describing the <code>HSL</code> in details the list conveniences will be shown and everything<br>should make more sense.</p><p>Once the <code>Forgefile</code> written, the forge should be invoked in the command line as follows:</p><blockquote>
<p><code>hefesto --forgefiles=Forgefile.hsl --Forgefile-projects=here</code></p>
</blockquote><p>The option —forgefiles specifies a file list which have the defined projects. The another option is dynamic and based on the passed file names by —forgefiles.<br>The general idea for this dynamic option is:</p><blockquote>
<p>—<file-name>-projects=<projects defined="" inside="" this="" file=""></projects></file-name></p>
</blockquote><p>Yes, I know:</p><blockquote>
<p>ZzZZzzzZzzzZzZZZZZZzzzzzzZzzzZzzzzzZZZZZZZzzzzZZZ the command is pretty longer… Can I use a shorter one instead?</p>
</blockquote><p>Yes you can, in this case you need to create an invocation file. This invocation file needs to reside inside where you are intending to invoke the forge. Into<br>this file you need to type the invocation command line.</p><p>Once the .ivk created, being inside its directory, all you should do is call hefesto without any option. If you pass some option, the options passed will<br>be merged with the option into the .ivk file.</p><p>Well, now you know the basic steps for composing a Forgefile. However, you do not know the general details about the HSL and how to create more toolsets<br>for your own necessities.</p><p>The toolsets are pieces of HSL code which can have their own conventions, conveniences, etc. Due to it, before using them a good thing to do is read the documentation about them.<br>If you are using some toolset from the official base, probably you can find some text detailing this related toolset.</p><h2 id="how-to-reprocess-only-what-have-changed-since-the-last-forge?"><a name="how-to-reprocess-only-what-have-changed-since-the-last-forge?" href="#how-to-reprocess-only-what-have-changed-since-the-last-forge?"></a>How to reprocess only what have changed since the last forge?</h2><p>For doing it is necessary to inform your worries about reprocessing issues when creating your project. Let’s use the previous lib sample.</p><p>Previously the project declaration was as follows:</p><pre><code data-origin="<pre><code>    project here : toolset &quot;gcc-c-lib&quot; : $sources, $includes, $cflags, $libraries, $ldflags, &quot;libhere.a&quot;;
</code></pre>">    project here : toolset "gcc-c-lib" : $sources, $includes, $cflags, $libraries, $ldflags, "libhere.a";
</code></pre><p>Now we will include the specfification of the dependency chain (a.k.a <code>dep-chain</code>). A <code>dep-chain</code> basically is a <code>string</code> expressed in a special format:</p><blockquote>
<p><code>&lt;file-path&gt;</code> <strong>:</strong>  <code>&lt;file-path_0&gt;</code> [ <strong>&amp;</strong> <code>&lt;file-path_n&gt;</code> ] <strong>;</strong></p>
</blockquote><p>If <code>a.x</code> depends on <code>b.x</code> which depends on <code>c.x</code> which depends on <code>d.x</code> and <code>e.x</code>. The <code>dep-chain</code> for this situation would be:</p><blockquote>
<p>a.x: b.x;</p>
<p>b.x: c.x;</p>
<p>c.x: d.x &amp; e.x;</p>
</blockquote><p>Real programs can have a extense <code>dep-chain</code>, the <code>Hefesto's</code> standard library includes some <code>HSL</code> functions for doing this job. Follows a practical<br>usage of the <code>dep-chains</code>:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset &quot;gcc-c-lib&quot; : dependencies $deps : $sources,
                                                              $includes,
                                                              $cflags,
                                                              $libraries,
                                                              $ldflags,
                                                              &quot;libhere.a&quot; ;

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset "gcc-c-lib" : dependencies $deps : $sources,
                                                              $includes,
                                                              $cflags,
                                                              $libraries,
                                                              $ldflags,
                                                              "libhere.a" ;

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(".*\\.c$");
    }
</code></pre><p>As you can see now the code is including the directive <code>dependencies &lt;string&gt;</code> onto project declaration. Besides the usage of the <code>get_c_cpp_deps()</code><br>function included from <code>dependency_scanner.hsl</code>. However, you could write down your own dependency chain without any function. A malformed dependency<br>chain is silently dropped by the application. </p><p>Done! With the dependency chain well-declared the source codes only will be processed when explictly changed or still other files which they<br>depend on are changed.</p><h4 id="how-to-enforce-the-re-processing-of-everything"><a name="how-to-enforce-the-re-processing-of-everything" href="#how-to-enforce-the-re-processing-of-everything"></a>How to enforce the re-processing of everything</h4><p>Use the option <code>--forge-anyway</code> when invoking the forge.</p><h4 id="more-details-about-the-*dep-chains*"><a name="more-details-about-the-*dep-chains*" href="#more-details-about-the-*dep-chains*"></a>More details about the <em>dep-chains</em></h4><p>When you adopt the usage of <code>dep-chains</code> the arguments which you use during the invocation start being watched. Then if you change some argument everything<br>will be reprocessed.</p><p>A file is considered changed when its content has actually changed.</p><h3 id="yoda`s-proposal:-what-about-at-run-time-change-the-toolset,-hmm?"><a name="yoda`s-proposal:-what-about-at-run-time-change-the-toolset,-hmm?" href="#yoda`s-proposal:-what-about-at-run-time-change-the-toolset,-hmm?"></a>Yoda`s proposal: What about at run-time change the toolset, hmm?</h3><p>Yes young <em>padawan</em>,  have no fear… it is possible. For doing it is necessary to take one Jedi’s care: the <em>toolsets</em> must have the same forge function interface, in other words, these functions must receive the same arguments, following the order and type of them.</p><p>Do you remember when the project’s <code>entry-points</code> were shown? Including the <code>entry-point</code> called <code>preloading</code> which occurs even before loading the <code>toolset</code>…<br>Let’s use this <code>big-bang</code> for creating a more suitable <em>Forgefile</em>.</p><p>Picking up the previous sample from that shown <em>lib</em>. Now suppose that we have the following requirement:</p><blockquote>
<p>When on <code>Windows</code> is necessary to use the <em>Visual Studio 2012</em>, being it installed. Otherwise, the <em>GCC</em> will be used. Still, under other platforms the <em>GCC</em> must be always used.</p>
</blockquote><p>Now, I will show the changed <em>Forgefile</em>. Ahead the interesting parts will be commented:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;
    var current_toolset type string;

    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   &quot;libhere.a&quot; ;

    function has_vs_110() : result type int {
        var winreg_rkey type list;
        $winreg_rkey.add_item(&quot;HKLM&quot;);
        $winreg_rkey.add_item(&quot;HKCU&quot;);

        var subkeys type list;
        $subkeys.add_item(&quot;\\SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0&quot;);
        $subkeys.add_item(&quot;\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0&quot;);

        var s type int;
        var subkey type string;
        var w type int;
        var root_key type string;
        var install_dir type string;

        $s = 0;
        while ($s &amp;lt; $subkeys.count()) {
            $subkey = $subkeys.item($s);
            $w = 0;
            while ($w &amp;lt; $winreg_rkey.count()) {
                $root_key = $winreg_rkey.item($w);
                $install_dir = hefesto.sys.env(&quot;WINREG:&quot; +
                                               $root_key +
                                               $subkey);
                if ($install_dir.len() &amp;gt; 0) result 1;
                $w = $w + 1;
            }
            $s = $s + 1;
       }
       result 0;
    }

    here.preloading() {
        $current_toolset = &quot;gcc-c-lib&quot;;
        if (hefesto.sys.os_name() == &quot;windows&quot;) {
            if (has_vs_110()) {
                $current_toolset = &quot;vc110-lib&quot;;
            }
        }
    }

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;
    var current_toolset type string;

    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   "libhere.a" ;

    function has_vs_110() : result type int {
        var winreg_rkey type list;
        $winreg_rkey.add_item("HKLM");
        $winreg_rkey.add_item("HKCU");

        var subkeys type list;
        $subkeys.add_item("\\SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0");
        $subkeys.add_item("\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0");

        var s type int;
        var subkey type string;
        var w type int;
        var root_key type string;
        var install_dir type string;

        $s = 0;
        while ($s &lt; $subkeys.count()) {
            $subkey = $subkeys.item($s);
            $w = 0;
            while ($w &lt; $winreg_rkey.count()) {
                $root_key = $winreg_rkey.item($w);
                $install_dir = hefesto.sys.env("WINREG:" +
                                               $root_key +
                                               $subkey);
                if ($install_dir.len() &gt; 0) result 1;
                $w = $w + 1;
            }
            $s = $s + 1;
       }
       result 0;
    }

    here.preloading() {
        $current_toolset = "gcc-c-lib";
        if (hefesto.sys.os_name() == "windows") {
            if (has_vs_110()) {
                $current_toolset = "vc110-lib";
            }
        }
    }

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(".*\\.c$");
    }
</code></pre><p>The function <code>has_vs_110</code> verifies if the registry entry related with <em>VS</em> exists. The section <code>About the HSL</code> shows more details about the used features.<br>When it exists the value <code>1</code> is returned, otherwise <code>0</code>.</p><p>Into the <code>preloading</code> we will call <code>has_vs_110</code> only being under <code>Windows</code>. Having the <code>VS</code> well-installed, the <em>Visual C</em> toolset is selected, otherwise<br>we will use the default tooselt which is the <em>GCC</em>.</p><p>The project declaration brings an indirection for the real toolset name by using the variable <code>$current_toolset</code>. As a result, being the variable content<br>changed even before trying to load the toolset (we have done it on <code>preloading</code> phase), we will have a toolset selection at the run-time.</p><pre><code data-origin="<pre><code>    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   &quot;libhere.a&quot; ;
</code></pre>">    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   "libhere.a" ;
</code></pre><p>Again, for doing it is necessary to have toolsets which share the same forge function interface.</p><p>However, there is a little “problem” with the shown sample. This sample starts with:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
</code></pre><p>The forge is multi-platform but we do not have to include the <em>Visual C</em> toolset every time. Being necessary to include it only when running it under <code>Windows</code> boxes.<br>An improvement related with it would be:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include on windows ~/toolsets/vc/vc110-lib.hsl
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include on windows ~/toolsets/vc/vc110-lib.hsl
</code></pre><p>Done!</p><p>The directive <code>include</code> accepts a platform list for effectively include one file. For instance, being necessity of including a file only under <code>FreeBSD</code> and <code> </code>Linux``. You should do:</p><pre><code data-origin="<pre><code>    include on freebsd,linux posix/utils.hsl
</code></pre>">    include on freebsd,linux posix/utils.hsl
</code></pre><h3 id="how-can-i-run-my-tests?"><a name="how-can-i-run-my-tests?" href="#how-can-i-run-my-tests?"></a>How can I run my tests?</h3><p>The usage of <code>batch-files</code> or even <code>shell-scripts</code> in order to run the tests is kind of annoying. Usually people tends to use these type of external scripting<br>tools for doing other pre/post processing operations. In my opinion, tidiness is related with uniformity. Less mixing into a build project is better. To keep everything expressed in the same language would be a paradise.</p><p>What about to use the <code>entry-point epilogue</code> for running your tests? You can not only run and break the build if something wrong occurs. Actually, you can also to build it besides running.</p><p>Follows an example based on the previous <em>lib</em> sample shown:</p><pre><code data-origin="<pre><code>    here.epilogue() {
        var notest type list;
        if (hefesto.sys.last_forge_result() == 0) {
            $notest = hefesto.sys.get_option(&quot;no-test&quot;);
            if ($notest.count() == 0) {
                run_tests();
            }
        }
    }

    function run_tests() : result type none {
        var retval type int;
        hefesto.sys.cd(&quot;test&quot;);
        $retval = hefesto.sys.forge(&quot;here-test&quot;, &quot;Forgefile.hsl&quot;, &quot;--bin-output-dir=bin --obj-output-dir=obj&quot;);
        hefesto.sys.cd(&quot;..&quot;);
    }
</code></pre>">    here.epilogue() {
        var notest type list;
        if (hefesto.sys.last_forge_result() == 0) {
            $notest = hefesto.sys.get_option("no-test");
            if ($notest.count() == 0) {
                run_tests();
            }
        }
    }

    function run_tests() : result type none {
        var retval type int;
        hefesto.sys.cd("test");
        $retval = hefesto.sys.forge("here-test", "Forgefile.hsl", "--bin-output-dir=bin --obj-output-dir=obj");
        hefesto.sys.cd("..");
    }
</code></pre><p>I am sorry if I am rushing a little bit the things here. Basically, on <code>epilogue</code> is verified if the lib was really <code>built</code>. If it was, the existence of the option <code>--no-test</code><br>is checked. If this option was not passed the function <code>run_tests</code> is called.</p><p>The function <code>run_tests</code> changes the current working directory for the sub-directory <code>test</code>. Into this sub-directory exists another forge. This another<br>forge is invoked. After its execution, the current working directory backs in one level.</p><p>Now it is necessary to see the tests’ forge:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-app.hsl

    var sources type list;
    var includes type list;
    var libraries type list;
    var ldflags type list;
    var cflags type list;

    project here-test : toolset &quot;gcc-c-app&quot; : $sources, $includes, $cflags,
                                    $libraries, $ldflags, &quot;here_unittest&quot; ;


    here-test.prologue() {
        $sources.ls(&quot;.*\\.c@@bodyquot;);
        $ldflags = hefesto.sys.get_option(&quot;ldflags&quot;);
        $ldflags.add_item(&quot;../lib/libhere.a&quot;);
        $includes = hefesto.sys.get_option(&quot;includes&quot;);
        $includes = hefesto.sys.get_option(&quot;libraries&quot;);
        $includes = hefesto.sys.get_option(&quot;cflags&quot;);
    }

    function run_unittests() : result type int {
        var retval type int;
        if (hefesto.sys.os_name() != &quot;windows&quot;) {
            $retval = hefesto.sys.run(&quot;bin/here_unittest&quot;);
        } else {
            $retval = hefesto.sys.run(&quot;bin\\here_unittest.exe&quot;);
        }
        result $retval;
    }

    here-test.epilogue() {
        if (hefesto.sys.last_forge_result() == 0) {
            if (run_unittests() != 0) hefesto.sys.exit(1);
        }
    }
</code></pre>">    include ~/toolsets/gcc/gcc-app.hsl

    var sources type list;
    var includes type list;
    var libraries type list;
    var ldflags type list;
    var cflags type list;

    project here-test : toolset "gcc-c-app" : $sources, $includes, $cflags,
                                    $libraries, $ldflags, "here_unittest" ;


    here-test.prologue() {
        $sources.ls(".*\\.c$");
        $ldflags = hefesto.sys.get_option("ldflags");
        $ldflags.add_item("../lib/libhere.a");
        $includes = hefesto.sys.get_option("includes");
        $includes = hefesto.sys.get_option("libraries");
        $includes = hefesto.sys.get_option("cflags");
    }

    function run_unittests() : result type int {
        var retval type int;
        if (hefesto.sys.os_name() != "windows") {
            $retval = hefesto.sys.run("bin/here_unittest");
        } else {
            $retval = hefesto.sys.run("bin\\here_unittest.exe");
        }
        result $retval;
    }

    here-test.epilogue() {
        if (hefesto.sys.last_forge_result() == 0) {
            if (run_unittests() != 0) hefesto.sys.exit(1);
        }
    }
</code></pre><p>The most important function here is the function <code>run_unittests</code>. This function is called from the project’s <code>epilogue</code>. Returning non-zero values<br>the forge will exit with 1. When a forge exit with non-zero value it makes the processing break.</p><p>I would say that I found my Paradise in <code>Hades</code>… :) I hope you too. Keep on reading the following sections. They intend to provide deeper details<br>about Hefesto. These details will be necessary for mastering this build tool.</p><h2 id="about-the-hsl"><a name="about-the-hsl" href="#about-the-hsl"></a>About the HSL</h2><p>It was not my initial intention to create a <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> for the <em>Hefesto</em>, the fact is that I have<br>seen the necessity for doing it when developing the main concepts and ideas discussed here. One of my main intentions was to solve my problems in a<br>general way, efficient and clean. With no workarounds, several huge and bloated external dependencies, etc. Because all of about it had already been<br>done and these tools never served me in a elegant and powerful way.</p><p>Summarizing, I had more work to do, more codes to write, however today I can automate much more besides only the compilation of something.<br>The best of it: all can be expressed in a single one Language. As a result the build complexities can really decrease. A clean build solution is better<br>than a Rube Goldberg machine for doing the same job. At least is what my sense takes me to think.</p><h3 id="why-a-new-*dsl*-instead-of-using-a-pre-existent-one?"><a name="why-a-new-*dsl*-instead-of-using-a-pre-existent-one?" href="#why-a-new-*dsl*-instead-of-using-a-pre-existent-one?"></a>Why a new <em>dsl</em> instead of using a pre-existent one?</h3><p>When using a General Purpose Language the complexities of this Language, unfortunately, will echo inside the related system. So a internal dsl would not help the users with its excessive conventions.<br>Still, it would make the discussed application quite dependent from other applications. Finally, it would bloat the solution with any real necessity.</p><h3 id="defining-the-basis"><a name="defining-the-basis" href="#defining-the-basis"></a>Defining the basis</h3><p>First of all, the <code>HSL</code> should only be used for automating builds. You should not try to implement general purpose software with it.</p><p>This language have 4 primitive types. There is not convention for using <em>user-defined types</em>, the <strong>Table 2</strong> lists these types.</p><p><strong>Tabela 2</strong>: Tipos primitivos presentes na <code>HSL</code>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Reserved word</strong></th>
<th style="text-align:center"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">32/64-bit integer</td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">Char sequence</td>
</tr>
<tr>
<td style="text-align:center"><code>file</code></td>
<td style="text-align:center">File descriptor</td>
</tr>
<tr>
<td style="text-align:center"><code>list</code></td>
<td style="text-align:center">Container for the types <code>int</code> or <code>string</code></td>
</tr>
</tbody>
</table><p>Fact: variables need to be declared.</p><p>From anywhere in a <code>HSL</code> code you can declare a variable. Following the scheme:</p><blockquote>
<p><strong>var</strong> <code>&lt;var-name&gt;</code> <strong>type</strong> <code>&lt;type-name&gt;</code> <strong>;</strong></p>
</blockquote><p>The <code>&lt;var-name&gt;</code> can be composed by <code>[A-Za-z0-9_]</code>. Only one declaration per line are allowed.</p><p>Practical examples:</p><pre><code data-origin="<pre><code>    var my_name type string;
    var my_age type int ;
    var my_sloopy_list_decl
    type
    list;
</code></pre>">    var my_name type string;
    var my_age type int ;
    var my_sloopy_list_decl
    type
    list;
</code></pre><p>To access a declared variable (sorry for the pleonasm), this variable need to be prefixed with the unary <code>$</code>:</p><pre><code data-origin="<pre><code>    $my_name = &quot;John doe.&quot;;
    $my_age = -1;
</code></pre>">    $my_name = "John doe.";
    $my_age = -1;
</code></pre><p>Conditional <code>branches</code> can be expressed in the following way:</p><blockquote>
<p><strong>if</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong> [ <strong>else</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong> ]</p>
</blockquote><p>or</p><blockquote>
<p><strong>if</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <code>&lt;hsl-single-stmt&gt;</code> [ <strong>else</strong> <code>&lt;hsl-single-stmt&gt;</code> ]</p>
</blockquote><p>There is only one way for expressing <code>loops</code>. Through <code>while</code>, see:</p><blockquote>
<p><strong>while</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong></p>
</blockquote><p>or</p><blockquote>
<p><strong>while</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <code>&lt;hsl-single-stmt&gt;</code></p>
</blockquote><p>The <strong>Table 3</strong> gathers the available operators to compose expressions in <code>HSL</code>.</p><p><strong>Table 3</strong>: Available operators until now.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Operator</strong></th>
<th style="text-align:center"><strong>Operation</strong></th>
<th style="text-align:center"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">Equals to</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">Not equals to</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">Less than</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">Greater than</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">Greater or equals to</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">Less of equals to</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">.AND.</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">.OR.</td>
<td style="text-align:center">Logical</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">.AND.</td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">.OR.</td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>Left Shift</code></td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>Right Shift</code></td>
<td style="text-align:center">Bitwise</td>
</tr>
</tbody>
</table><p>Functions can return any primitive type or none. The general form of declaring functions is:</p><blockquote>
<p><strong>function</strong> <code>&lt;function-name&gt;</code> <strong>(</strong> <code>&lt;var-decl-list&gt;</code> <strong>)</strong> <strong>: result type </strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong></p>
</blockquote><p>The accepted charset for naming functions are the same accepted for naming variables.</p><p>A practical example… A function which recursively evaluates a factorial from a given number:</p><pre><code data-origin="<pre><code>    function factorial(n type int) : result type int {
        if ($n == 0) return 1;
        return factorial($n - 1) * $n;
    }
</code></pre>">    function factorial(n type int) : result type int {
        if ($n == 0) return 1;
        return factorial($n - 1) * $n;
    }
</code></pre><p>A function which returns none, whose <code>return type</code> should be <code>none</code>:</p><pre><code data-origin="<pre><code>    function say_hello() : result type none
    {
        hefesto.sys.echo(&quot;Hello, creative mind....\n&quot;);
    }
</code></pre>">    function say_hello() : result type none
    {
        hefesto.sys.echo("Hello, creative mind....\n");
    }
</code></pre><h3 id="the-*hefesto-syscalls*"><a name="the-*hefesto-syscalls*" href="#the-*hefesto-syscalls*"></a>The <em>Hefesto Syscalls</em></h3><p>Well, the last example of a useless function which only says “hello”, was not so useless… It was handy for creating one question:</p><blockquote>
<p>“WTF is <code>hefesto.sys.whatever</code>??”</p>
</blockquote><p>Nothing is really random, believe it! A <a href="http://en.wikipedia.org/wiki/Eastern_mole#/media/File:ScalopusAquaticus.jpg">terrible</a> writer <a href="https://what-if.xkcd.com/4/">mole</a> has buried<br>that strange thing there to make you stumble and fall here. When I started to think about the HSL one of my main questions were: which tasks are common during a build task?<br>Which from these tasks are directly or indirectly requested (dependant) from the Operating System?</p><p>These questions led me to create an abstraction layer which guarantees to write common steps of a <em>build task</em> independently from which Operating System should execute them.</p><p>The abstraction layer can be accessed by the Hefesto’s <code>sys sub-system</code>. In the following way:</p><blockquote>
<p><code>hefesto.sys.&lt;sys-call&gt;(&lt;arg-list&gt;)</code></p>
</blockquote><p>This <code>sub-system</code> is called <code>syscalls</code>. Do not be fooled by its name. In fact, you will find much more than classical concepts of <em>“syscalls”</em> on it.<br>You will find things that do much more on a single call and on a higher level than the good and old <em>UNIX syscalls</em>.</p><p>I picked this name because during my work I have figured out that the majority porting issues of a build task are directly or indirectly related with some real <em>syscall</em>.<br>Then here is explained the source of any future misconception.</p><p>In <em>Table 4</em> are listed the related <code>syscall</code>.</p><p><strong>Table 4</strong>: <code>Hefesto syscalls</code> currently implenented.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Syscall</strong></th>
<th style="text-align:right"><strong>Utility</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>replace_in_file()</code></td>
<td style="text-align:right">replaces a found text by a regular expression</td>
</tr>
<tr>
<td style="text-align:center"><code>lines_from_file()</code></td>
<td style="text-align:right">filters lines which match with the passed regular expression</td>
</tr>
<tr>
<td style="text-align:center"><code>ls()</code></td>
<td style="text-align:right">returns the count of found files by the passed regular expression</td>
</tr>
<tr>
<td style="text-align:center"><code>pwd()</code></td>
<td style="text-align:right">returns the current working directory (full path)</td>
</tr>
<tr>
<td style="text-align:center"><code>cd()</code></td>
<td style="text-align:right">jumps to the passed directory path</td>
</tr>
<tr>
<td style="text-align:center"><code>rm()</code></td>
<td style="text-align:right">removes a passed file path</td>
</tr>
<tr>
<td style="text-align:center"><code>cp()</code></td>
<td style="text-align:right">copies a file/directory to a passed destination</td>
</tr>
<tr>
<td style="text-align:center"><code>mkdir()</code></td>
<td style="text-align:right">creates a directory</td>
</tr>
<tr>
<td style="text-align:center"><code>rmdir()</code></td>
<td style="text-align:right">removes a directory</td>
</tr>
<tr>
<td style="text-align:center"><code>fopen()</code></td>
<td style="text-align:right">opens a file returning the related file descriptor (file type)</td>
</tr>
<tr>
<td style="text-align:center"><code>fwrite()</code></td>
<td style="text-align:right">writes data into the passed file descriptor</td>
</tr>
<tr>
<td style="text-align:center"><code>fread()</code></td>
<td style="text-align:right">reads data from the passed file descriptor</td>
</tr>
<tr>
<td style="text-align:center"><code>fclose()</code></td>
<td style="text-align:right">cleans all allocated resources related with the passed file descriptor</td>
</tr>
<tr>
<td style="text-align:center"><code>feof()</code></td>
<td style="text-align:right">verifies if it is the end of file</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek()</code></td>
<td style="text-align:right">jumps to a specified file’s offset</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek_to_begin()</code></td>
<td style="text-align:right">jumps to the beginning of file</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek_to_end()</code></td>
<td style="text-align:right">jumps to the end of file</td>
</tr>
<tr>
<td style="text-align:center"><code>fsize()</code></td>
<td style="text-align:right">returns the file size (in bytes)</td>
</tr>
<tr>
<td style="text-align:center"><code>ftell()</code></td>
<td style="text-align:right">returns the current file offset</td>
</tr>
<tr>
<td style="text-align:center"><code>run()</code></td>
<td style="text-align:right">runs an external process returning its exit code</td>
</tr>
<tr>
<td style="text-align:center"><code>echo()</code></td>
<td style="text-align:right">write data into the stdout</td>
</tr>
<tr>
<td style="text-align:center"><code>env()</code></td>
<td style="text-align:right">returns the content of a environment variable</td>
</tr>
<tr>
<td style="text-align:center"><code>prompt()</code></td>
<td style="text-align:right">reads data from the keyboard waiting for the confirmation by the <em>ENTER</em> pressing</td>
</tr>
<tr>
<td style="text-align:center"><code>exit()</code></td>
<td style="text-align:right">aborts the Hefesto virtual machine changing the exit code to the passed value</td>
</tr>
<tr>
<td style="text-align:center"><code>os_name()</code></td>
<td style="text-align:right">returns the current platform name</td>
</tr>
<tr>
<td style="text-align:center"><code>get_option()</code></td>
<td style="text-align:right">returns the data of a passed command line</td>
</tr>
<tr>
<td style="text-align:center"><code>make_path()</code></td>
<td style="text-align:right">creates a string taking two halves which corresponds a valid path for the current platform</td>
</tr>
<tr>
<td style="text-align:center"><code>last_forge_result()</code></td>
<td style="text-align:right">gets the exit code of the last executed forge process</td>
</tr>
<tr>
<td style="text-align:center"><code>forge()</code></td>
<td style="text-align:right">invokes another forge project</td>
</tr>
<tr>
<td style="text-align:center"><code>byref()</code></td>
<td style="text-align:right">updates the value of a function’s argument into the external variable passed as this local argument</td>
</tr>
<tr>
<td style="text-align:center"><code>time()</code></td>
<td style="text-align:right">returns a string representing the current system Time according to the passed format</td>
</tr>
<tr>
<td style="text-align:center"><code>setenv()</code></td>
<td style="text-align:right">creates an environment variable (volatile)</td>
</tr>
<tr>
<td style="text-align:center"><code>unsetenv()</code></td>
<td style="text-align:right">removes an environment variable (volatile)</td>
</tr>
<tr>
<td style="text-align:center"><code>call_from_module()</code></td>
<td style="text-align:right">calls a function implemented into a shared library</td>
</tr>
<tr>
<td style="text-align:center"><code>get_func_addr()</code></td>
<td style="text-align:right">returns the address of a passed function name</td>
</tr>
<tr>
<td style="text-align:center"><code>call_func_addr()</code></td>
<td style="text-align:right">tries to make a function call from the passed address</td>
</tr>
</tbody>
</table><h4 id="a-practical-guide-for-each-*hefesto-syscall*"><a name="a-practical-guide-for-each-*hefesto-syscall*" href="#a-practical-guide-for-each-*hefesto-syscall*"></a>A practical guide for each <em>Hefesto syscall</em></h4><p>In this section you can explore details about how to use each <code>syscall</code>. Seeing more details about the received arguments. Also what they<br>return. All with short and straightforward samples (not always useful [i.e.: samples in state of art]).</p><h5 id="++replace_in_file()++"><a name="++replace_in_file()++" href="#++replace_in_file()++"></a><ins>replace_in_file()</ins></h5><p>Replaces data in a file. The first argument should be the <code>file path</code>, the second is the search pattern (regex), the third is the substitution pattern.<br>This <code>syscall</code> returns the number of done replacements.</p><pre><code data-origin="<pre><code>    function replace_in_file_sample() : result type none {
        var replacements_nr type int;
         $replacements_nr = hefesto.sys.replace_in_file(&quot;test.txt&quot;, &quot;^foo.*&quot;, &quot;all initial foo to bar&quot;);
        hefesto.sys.echo(&quot;Number of replacements: &quot; + $replacements_nr);
    }
</code></pre>">    function replace_in_file_sample() : result type none {
        var replacements_nr type int;
         $replacements_nr = hefesto.sys.replace_in_file("test.txt", "^foo.*", "all initial foo to bar");
        hefesto.sys.echo("Number of replacements: " + $replacements_nr);
    }
</code></pre><h5 id="++lines_from_file()++"><a name="++lines_from_file()++" href="#++lines_from_file()++"></a><ins>lines_from_file()</ins></h5><p>Filters lines from a file. The first argument should be the <code>file path</code>, the second is the search pattern (regex). This <code>syscall</code> returns a list containing<br>the filtered lines.</p><pre><code data-origin="<pre><code>    function lines_from_file_sample() : result type none {
         var retval type list;
         $retval = hefesto.sys.lines_from_file(&quot;test.txt&quot;, &quot;^foo.*&quot;);
    }
</code></pre>">    function lines_from_file_sample() : result type none {
         var retval type list;
         $retval = hefesto.sys.lines_from_file("test.txt", "^foo.*");
    }
</code></pre><h5 id="++ls()++"><a name="++ls()++" href="#++ls()++"></a><ins>ls()</ins></h5><p>Lists files into the current working directory. Receives a argument which is the listing pattern (regex). This <code>syscall</code> returns the number of found files.</p><pre><code data-origin="<pre><code>    function ls_sample() : result type none {
         if (hefesto.sys.ls(&quot;.*(c|cpp|s|asm)@@bodyquot;) &amp;gt; 0) {
              hefesto.sys.echo(&quot;Hey Beavis, Huh cool files to delete here!! Yeah yeah! Butt-head remove them! remove them!\n&quot;);
         } else {
              hefesto.sys.echo(&quot;ohh, nothing to screw up here.\n&quot;);
         }
    }
</code></pre>">    function ls_sample() : result type none {
         if (hefesto.sys.ls(".*(c|cpp|s|asm)$") &gt; 0) {
              hefesto.sys.echo("Hey Beavis, Huh cool files to delete here!! Yeah yeah! Butt-head remove them! remove them!\n");
         } else {
              hefesto.sys.echo("ohh, nothing to screw up here.\n");
         }
    }
</code></pre><h5 id="++pwd()++"><a name="++pwd()++" href="#++pwd()++"></a><ins>pwd()</ins></h5><p>Returns the current work directory as a string. This is hard to use. Look:</p><pre><code data-origin="<pre><code>    function pwd_only_to_PHDs() : result type none {
         hefesto.sys.echo(&quot;The current work directory is: &quot; + hefesto.sys.pwd() + &quot;\n&quot;);
    }
</code></pre>">    function pwd_only_to_PHDs() : result type none {
         hefesto.sys.echo("The current work directory is: " + hefesto.sys.pwd() + "\n");
    }
</code></pre><h5 id="++cd()++"><a name="++cd()++" href="#++cd()++"></a><ins>cd()</ins></h5><p>Changes the <code>cwd</code> to the passed directory. Returning <code>1</code> for success and <code>0</code> for failure.</p><pre><code data-origin="<pre><code>    function cd_sample() : result type none {
         hefesto.sys.cd(&quot;/home/rs&quot;);
    }
</code></pre>">    function cd_sample() : result type none {
         hefesto.sys.cd("/home/rs");
    }
</code></pre><h5 id="++rm()++"><a name="++rm()++" href="#++rm()++"></a><ins>rm()</ins></h5><p>Removes a file.</p><pre><code data-origin="<pre><code>    function rm_sample() : result type none {
         hefesto.sys.rm(&quot;some.lint~&quot;);
    }
</code></pre>">    function rm_sample() : result type none {
         hefesto.sys.rm("some.lint~");
    }
</code></pre><h5 id="++cp()++"><a name="++cp()++" href="#++cp()++"></a><ins>cp()</ins></h5><p>Copies a file/directory. The first argument is the regex pattern which correponds the source. The second argument is the destination. Returns <code>1</code> for success<br>and <code>0</code> for failure.</p><pre><code data-origin="<pre><code>    function cp_sample() : result type none {
         hefesto.sys.cp(&quot;.*\\.(exe|dll|msi)@@bodyquot;, &quot;wpkg&quot;);
    }
</code></pre>">    function cp_sample() : result type none {
         hefesto.sys.cp(".*\\.(exe|dll|msi)$", "wpkg");
    }
</code></pre><h5 id="++mkdir()++"><a name="++mkdir()++" href="#++mkdir()++"></a><ins>mkdir()</ins></h5><p>Creates a directory under the <code>cwd</code>. </p><pre><code data-origin="<pre><code>    function mkdir_sample() : result type none {
         hefesto.sys.mkdir(&quot;wpkg&quot;);
    }
</code></pre>">    function mkdir_sample() : result type none {
         hefesto.sys.mkdir("wpkg");
    }
</code></pre><h5 id="++rmdir()++"><a name="++rmdir()++" href="#++rmdir()++"></a><ins>rmdir()</ins></h5><p>Removes a empty directory.</p><pre><code data-origin="<pre><code>    function rmdir_sample() : result type none {
         hefesto.sys.rmdir(&quot;stage&quot;);
    }
</code></pre>">    function rmdir_sample() : result type none {
         hefesto.sys.rmdir("stage");
    }
</code></pre><h5 id="++fopen()++"><a name="++fopen()++" href="#++fopen()++"></a><ins>fopen()</ins></h5><p>Opens a file descriptor which can be manipulated by other <code>syscalls</code>. The first argument is the <code>file path</code>. The second is the openning mode. These openning<br>mode argument follows the standard <code>fopen</code> from the <code>libc</code> (“r” = read-only, “w” = write-only, “a” = <code>append</code> mode). If the <code>syscall</code> fails is returned<br>the value <code>0</code>, otherwise non-zero values will be returned.</p><pre><code data-origin="<pre><code>    function fopen_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;a&quot;);
    }
</code></pre>">    function fopen_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "a");
    }
</code></pre><h5 id="++fwrite()++"><a name="++fwrite()++" href="#++fwrite()++"></a><ins>fwrite()</ins></h5><p>Writes data to a file descriptor previous opened with file writing or appending mode. The first argument is the data <code>buffer</code>. The second is the buffer size.<br>The third is the file descriptor. This syscall returns the number of written bytes or <code>-1</code> when some error happens.</p><pre><code data-origin="<pre><code>    function fwrite_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;a&quot;);
         var buf type string;
         $buf = &quot;that's all folks for fwrite!\n&quot;;
         hefesto.sys.fwrite($buf, $buf.len(), $fp);
    }
</code></pre>">    function fwrite_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "a");
         var buf type string;
         $buf = "that's all folks for fwrite!\n";
         hefesto.sys.fwrite($buf, $buf.len(), $fp);
    }
</code></pre><h5 id="++fread()++"><a name="++fread()++" href="#++fread()++"></a><ins>fread()</ins></h5><p>Reads data from a file descriptor (obvious: opened with reading mode). After reading it advances the file descriptor according to the amount of reading bytes.<br>The first argument is the data <code>buffer</code>. The second argument indicates the amount of data that should be read. The third argument is the file descriptor.<br>This <code>syscall</code> returns the number of read bytes or <code>-1</code> when happening some error.</p><pre><code data-origin="<pre><code>    function fread_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         var byte type string
         hefesto.sys.fread($byte, 1, $fp);
    }
</code></pre>">    function fread_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         var byte type string
         hefesto.sys.fread($byte, 1, $fp);
    }
</code></pre><h5 id="++fclose()++"><a name="++fclose()++" href="#++fclose()++"></a><ins>fclose()</ins></h5><p>Closes/cleans all internal resources related with the passed file descriptor.</p><pre><code data-origin="<pre><code>    function fclose_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;w&quot;);
         # TODO: do some manipulation here...
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fclose_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "w");
         # TODO: do some manipulation here...
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++feof()++"><a name="++feof()++" href="#++feof()++"></a><ins>feof()</ins></h5><p>Returns <code>1</code> if the end of file was reached, otherwise <code>0</code>. This <code>syscall</code> receives the file descriptor which should be verified.</p><pre><code data-origin="<pre><code>    function feof_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         if (hefesto.sys.feof($fp) == 1) {
              hefesto.sys.echo(&quot;file end.\n&quot;);
        } else hefesto.sys.echo(&quot;NOT file end.\n&quot;);
             hefesto.sys.fclose($fp);
        }
    }
</code></pre>">    function feof_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         if (hefesto.sys.feof($fp) == 1) {
              hefesto.sys.echo("file end.\n");
        } else hefesto.sys.echo("NOT file end.\n");
             hefesto.sys.fclose($fp);
        }
    }
</code></pre><h5 id="++fseek()++"><a name="++fseek()++" href="#++fseek()++"></a><ins>fseek()</ins></h5><p>Jumps to a specified file offset (always absolute). The first argument is the file descriptor. The second is the wanted new <code>offset</code>.</p><pre><code data-origin="<pre><code>    function fseek_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek($fp, 10);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek($fp, 10);
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fseek_to_begin()++"><a name="++fseek_to_begin()++" href="#++fseek_to_begin()++"></a><ins>fseek_to_begin()</ins></h5><p>Jumps to the beginning of file. Receives a file descriptor.</p><pre><code data-origin="<pre><code>    function fseek_to_begin_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek_to_begin($fp); # yes this is a very useless dummy sample... :D
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_to_begin_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek_to_begin($fp); # yes this is a very useless dummy sample... :D
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fseek_to_end()++"><a name="++fseek_to_end()++" href="#++fseek_to_end()++"></a><ins>fseek_to_end()</ins></h5><p>Jumps to the end of file. Receives a file descriptor.</p><pre><code data-origin="<pre><code>    function fseek_to_end_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek_to_end($fp);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_to_end_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek_to_end($fp);
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fsize()++"><a name="++fsize()++" href="#++fsize()++"></a><ins>fsize()</ins></h5><p>Returns the amount in <code>bytes</code> of the passed file descriptor.</p><pre><code data-origin="<pre><code>    function fsize_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.echo(&quot;The file has &quot; + hefesto.sys.fsize($fp) + &quot;byte(s).\n&quot;);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fsize_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.echo("The file has " + hefesto.sys.fsize($fp) + "byte(s).\n");
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++ftell()++"><a name="++ftell()++" href="#++ftell()++"></a><ins>ftell()</ins></h5><p>Returns the current offset of the passed file descriptor.</p><pre><code data-origin="<pre><code>    function ftell_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.echo(&quot;The current offset should be 0 and is &quot; + hefesto.sys.ftell($fp) + &quot;.\n&quot;);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function ftell_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.echo("The current offset should be 0 and is " + hefesto.sys.ftell($fp) + ".\n");
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++run()++"><a name="++run()++" href="#++run()++"></a><ins>run()</ins></h5><p>Runs an external process returning its exit code. The <code>run</code> call is always syncroned.</p><pre><code data-origin="<pre><code>    function sync_run_sample() : result type none {
         hefesto.sys.echo(&quot;ls /dev exits with &quot; + hefesto.sys.run(&quot;ls /dev&quot;) + &quot; exit code.\n&quot;);
    }
</code></pre>">    function sync_run_sample() : result type none {
         hefesto.sys.echo("ls /dev exits with " + hefesto.sys.run("ls /dev") + " exit code.\n");
    }
</code></pre><p>You can also run <em>n</em> processes if you pass to this <code>syscall</code> a list containing command lines for being executed. The number of concurrent process is controlled<br>by the option <code>--qsize=n</code>. In this mode, the <code>syscall</code> returns the sum of the exit codes.</p><pre><code data-origin="<pre><code>    function async_run_sample() : result type none {
         var wqueue type list;
         $wqueue.add_item(&quot;ls /dev&quot;);
         $wqueue.add_item(&quot;ls /home/rs&quot;);
         $wqueue.add_item(&quot;echo \&quot;duh!\&quot;&quot;);
         hefesto.sys.echo(&quot;The work queue exit code is &quot; + hefesto.sys.run($wqueue) + &quot;.\n&quot;);
    }
</code></pre>">    function async_run_sample() : result type none {
         var wqueue type list;
         $wqueue.add_item("ls /dev");
         $wqueue.add_item("ls /home/rs");
         $wqueue.add_item("echo \"duh!\"");
         hefesto.sys.echo("The work queue exit code is " + hefesto.sys.run($wqueue) + ".\n");
    }
</code></pre><h5 id="++echo()++"><a name="++echo()++" href="#++echo()++"></a><ins>echo()</ins></h5><p>Prints a <code>string</code> on the stdout. In fact, this <code>Hefesto syscall</code> is pretty complicated.</p><pre><code data-origin="<pre><code>    function echo_sample() : result type none {
         hefesto.sys.echo(&quot;Hello world.\n&quot;);
    }
</code></pre>">    function echo_sample() : result type none {
         hefesto.sys.echo("Hello world.\n");
    }
</code></pre><h5 id="++env()++"><a name="++env()++" href="#++env()++"></a><ins>env()</ins></h5><p>Returns the data from a passed environment variable.</p><pre><code data-origin="<pre><code>    function env_sample() : result type none {
         hefesto.sys.echo(&quot;The current content of Windows PATH variable is = \&quot;&quot; + hefesto.sys.env(&quot;PATH&quot;) + &quot;\&quot;\n&quot;);
    }
</code></pre>">    function env_sample() : result type none {
         hefesto.sys.echo("The current content of Windows PATH variable is = \"" + hefesto.sys.env("PATH") + "\"\n");
    }
</code></pre><h5 id="++prompt()++"><a name="++prompt()++" href="#++prompt()++"></a><ins>prompt()</ins></h5><p>Returns the read data from keyboard.</p><pre><code data-origin="<pre><code>    function prompt_sample() : result type none {
         var usr_data type string;
         $usr_data = hefesto.sys.prompt(&quot;Type about an idea and then press enter to confirm this: \n&quot;);
         hefesto.sys.echo(&quot;Hey I had an idea: &quot; + $usr_data + &quot;\nWhat do you think?&quot;);
    }
</code></pre>">    function prompt_sample() : result type none {
         var usr_data type string;
         $usr_data = hefesto.sys.prompt("Type about an idea and then press enter to confirm this: \n");
         hefesto.sys.echo("Hey I had an idea: " + $usr_data + "\nWhat do you think?");
    }
</code></pre><h5 id="++exit()++"><a name="++exit()++" href="#++exit()++"></a><ins>exit()</ins></h5><p>Aborts the <code>HVM</code> execution exiting with the passed code.</p><pre><code data-origin="<pre><code>    function exit_sample() : result type none {
         hefesto.sys.exit(1);
    }
</code></pre>">    function exit_sample() : result type none {
         hefesto.sys.exit(1);
    }
</code></pre><h5 id="++os_name()++"><a name="++os_name()++" href="#++os_name()++"></a><ins>os_name()</ins></h5><p>Returns the name of the current platform where your <code>HSL</code> script is running. The name is always represented in <code>lower-case</code> without any information about<br>version. Under unix-likes it will be the name (in lower-case) returned by the <code>uname -s</code> (call/command).</p><pre><code data-origin="<pre><code>    function env_sample() : result type none {
         if (hefesto.sys.os_name() == &quot;windows&quot;) {
              hefesto.sys.echo(&quot;The current content of Windows PATH variable is = \&quot;&quot; + hefesto.sys.env(&quot;PATH&quot;) + &quot;\&quot;\n&quot;);
         }
    }
</code></pre>">    function env_sample() : result type none {
         if (hefesto.sys.os_name() == "windows") {
              hefesto.sys.echo("The current content of Windows PATH variable is = \"" + hefesto.sys.env("PATH") + "\"\n");
         }
    }
</code></pre><h5 id="++get_option()++"><a name="++get_option()++" href="#++get_option()++"></a><ins>get_option()</ins></h5><p>Returns the argument list of a given command line option. If there is no option related is returned an empty list.</p><pre><code data-origin="<pre><code>    function get_option_sample() : result type none {
         var cups_of_tea type list;
         $cups_of_tea = hefesto.sys.get_option(&quot;cups-of-tea&quot;); # --cups-of-tea=brown,black,green,red
         if ($cups_of_tea.size() == 0)
              hefesto.sys.echo(&quot;--cups-of-tea option not supplied.\n&quot;);
         else
              hefesto.sys.echo(&quot;--cups-of-tea option supplied.\n&quot;);
    }
</code></pre>">    function get_option_sample() : result type none {
         var cups_of_tea type list;
         $cups_of_tea = hefesto.sys.get_option("cups-of-tea"); # --cups-of-tea=brown,black,green,red
         if ($cups_of_tea.size() == 0)
              hefesto.sys.echo("--cups-of-tea option not supplied.\n");
         else
              hefesto.sys.echo("--cups-of-tea option supplied.\n");
    }
</code></pre><h5 id="++make_path()++"><a name="++make_path()++" href="#++make_path()++"></a><ins>make_path()</ins></h5><p>Makes an <code>string path</code> following the current platform conventions for it. The first argument is the <code>root path</code>. The second argument is the <em>addendum</em> of<br>this <code>path</code>. Returns a string representing the right combination of these two halves.</p><pre><code data-origin="<pre><code>    function make_path_sample() : result type none {
         hefesto.sys.echo(&quot;STRING PATH must be /home/rs \&quot;&quot; + hefesto.sys.make_path(&quot;/home&quot;, &quot;/rs&quot;) + &quot;\&quot;\n.&quot;);
    }
</code></pre>">    function make_path_sample() : result type none {
         hefesto.sys.echo("STRING PATH must be /home/rs \"" + hefesto.sys.make_path("/home", "/rs") + "\"\n.");
    }
</code></pre><h5 id="++last_forge_result()++"><a name="++last_forge_result()++" href="#++last_forge_result()++"></a><ins>last_forge_result()</ins></h5><p>Returns the last exit code related with the last executed forge (this <code>result</code> can be changed by the <code>exit syscall</code>).</p><pre><code data-origin="<pre><code>    function last_forge_result_sample() : result type none {
         hefesto.sys.echo(&quot;The last forge result was &quot; + hefesto.sys.last_forge_result() + &quot;.\n&quot;);
    }
</code></pre>">    function last_forge_result_sample() : result type none {
         hefesto.sys.echo("The last forge result was " + hefesto.sys.last_forge_result() + ".\n");
    }
</code></pre><h5 id="++forge()++"><a name="++forge()++" href="#++forge()++"></a><ins>forge()</ins></h5><p>Invokes another forge project. The first argument is the project contained inside the <code>HSL</code> informed by the second argument. The third argument are the desired<br>user options for this forge. This <code>syscall</code> returns the forge exit code and also changes the <code>last_forge_result's</code> returned value.</p><pre><code data-origin="<pre><code>    function forge_sample() : result type none {
         hefesto.sys.forge(&quot;foolib&quot;, &quot;local_deps.hsl&quot;, &quot;--user-includes-home=../alt_incs --pre-submit-me&quot;);
         if (hefesto.sys.last_forge_result() == 0) {
              hefesto.sys.echo(&quot;foolib built with success.\n&quot;);
         } else {
              hefesto.sys.echo(&quot;unable to build foolib.\n&quot;);
              hefesto.sys.exit(1);
         }
    }
</code></pre>">    function forge_sample() : result type none {
         hefesto.sys.forge("foolib", "local_deps.hsl", "--user-includes-home=../alt_incs --pre-submit-me");
         if (hefesto.sys.last_forge_result() == 0) {
              hefesto.sys.echo("foolib built with success.\n");
         } else {
              hefesto.sys.echo("unable to build foolib.\n");
              hefesto.sys.exit(1);
         }
    }
</code></pre><h5 id="++byref()++"><a name="++byref()++" href="#++byref()++"></a><ins>byref()</ins></h5><p>Updates the data from a local function argument to an external variable which acted as this function argument during a call for the function itself. This<br><code>syscall</code> receives the local function argument which should be upload the data to the external argument.</p><pre><code data-origin="<pre><code>    function caller() : result type none {
         var return type string;
         $return = &quot;foo&quot;;
         hefesto.sys.echo($return);
         byref_sample($return);
         hefesto.sys.echo($return + &quot;\n&quot;);
    }

    function byref_sample(io_var type string) : result type none {
         $io_var = &quot;bar&quot;;
         hefesto.sys.byref($io_var);
    }
</code></pre>">    function caller() : result type none {
         var return type string;
         $return = "foo";
         hefesto.sys.echo($return);
         byref_sample($return);
         hefesto.sys.echo($return + "\n");
    }

    function byref_sample(io_var type string) : result type none {
         $io_var = "bar";
         hefesto.sys.byref($io_var);
    }
</code></pre><h5 id="++time()++"><a name="++time()++" href="#++time()++"></a><ins>time()</ins></h5><p>Returns a <code>string</code> representing the current system Time according to the passed format. The accepted formats are the same accepted by the function <code>strftime()</code><br>from the <code>libc</code> present on the related Operating System.</p><pre><code data-origin="<pre><code>    function time_sample() : result type none {
         hefesto.sys.echo(&quot;Current time: &quot; + hefesto.sys.time(&quot;%H:%M&quot;) + &quot;\n&quot;);
    }
</code></pre>">    function time_sample() : result type none {
         hefesto.sys.echo("Current time: " + hefesto.sys.time("%H:%M") + "\n");
    }
</code></pre><h5 id="++setenv()++"><a name="++setenv()++" href="#++setenv()++"></a><ins>setenv()</ins></h5><p>Creates an environment variable. However, this is a volatile operation. At the end of the process this variable is lost.</p><pre><code data-origin="<pre><code>    function setenv_sample() : result type none {
         hefesto.sys.setenv(&quot;mytempvar&quot;, &quot;mytempval&quot;);
    }
</code></pre>">    function setenv_sample() : result type none {
         hefesto.sys.setenv("mytempvar", "mytempval");
    }
</code></pre><p>On <code>Windows</code> you can to use this <code>syscall</code> for accessing the registry too. It is necessary to inform the full path where the wanted value should<br>be saved, prefixing this path with <code>WINREG:</code>. In this case, this operation is non-volatile.</p><pre><code data-origin="<pre><code>    function setenv_sample() : result type none {
         hefesto.sys.setenv(&quot;WINREG:HKCU\\Software\\Abc\\mytempvar:REG_SZ&quot;, &quot;mytempval&quot;);
    }
</code></pre>">    function setenv_sample() : result type none {
         hefesto.sys.setenv("WINREG:HKCU\\Software\\Abc\\mytempvar:REG_SZ", "mytempval");
    }
</code></pre><h5 id="++unsetenv()++"><a name="++unsetenv()++" href="#++unsetenv()++"></a><ins>unsetenv()</ins></h5><p>Removes a specified environment variable. This is a volatile operation. Only affecting the <code>HVM</code> process where this <code>syscall</code> was called.</p><pre><code data-origin="<pre><code>    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv(&quot;VSCOMPILERPATH&quot;);
    }
</code></pre>">    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv("VSCOMPILERPATH");
    }
</code></pre><p>On <code>Windows</code> you can to use this <code>syscall</code> for removing (permanently) registry values too. In the following way:</p><pre><code data-origin="<pre><code>    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv(&quot;WINREG:HKLM\\Software\\Abc\\mytempvar&quot;);
    }
</code></pre>">    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv("WINREG:HKLM\\Software\\Abc\\mytempvar");
    }
</code></pre><h5 id="++call_from_module()++"><a name="++call_from_module()++" href="#++call_from_module()++"></a><ins>call_from_module()</ins></h5><p>Calls a function implemented inside a shared library.</p><p>The shared function needs to be implemented using a special data structure. More info can be found in the specific documentation about it.</p><pre><code data-origin="<pre><code>    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module(&quot;/usr/share/mymods/my_killer_mod.so&quot;, &quot;killer_func&quot;, &quot;arg1&quot;, &quot;arg2&quot;, 3);
    }
</code></pre>">    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module("/usr/share/mymods/my_killer_mod.so", "killer_func", "arg1", "arg2", 3);
    }
</code></pre><p>You can also use the path indirection for generalizing the modules locating process.</p><pre><code data-origin="<pre><code>    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module(&quot;~/my_killer_mod.so&quot;, &quot;killer_func&quot;, &quot;arg1&quot;, &quot;arg2&quot;, 3);
    }
</code></pre>">    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module("~/my_killer_mod.so", "killer_func", "arg1", "arg2", 3);
    }
</code></pre><p>In this case, the library <code>"my_killer_mod.so"</code> will be searched on the configurated paths (into the <code>HEFESTO_MODULES_HOME</code>) besides the<br>current working directory.</p><h5 id="++get_func_addr()++"><a name="++get_func_addr()++" href="#++get_func_addr()++"></a><ins>get_func_addr()</ins></h5><p>Returns the address of a passed function name.</p><pre><code data-origin="<pre><code>    function get_func_addr_sample() : result type int {
         result hefesto.sys.get_func_addr(&quot;dummy_clbk&quot;);
    }
</code></pre>">    function get_func_addr_sample() : result type int {
         result hefesto.sys.get_func_addr("dummy_clbk");
    }
</code></pre><h5 id="++call_func_addr()++"><a name="++call_func_addr()++" href="#++call_func_addr()++"></a><ins>call_func_addr()</ins></h5><p>Tries to call a function from a passed execution address. If something wrong occurs during this process a run-time error is thrown.</p><pre><code data-origin="<pre><code>    function call_func_addr_sample() : result type int {
         var clbk_p type int;
         $clbk_p = hefesto.sys.get_func_addr(&quot;abc_one_two_three&quot;);
         result hefesto.sys.call_from_addr($clbk_p, &quot;abc&quot;, 1, &quot;two&quot;, 3);
    }
</code></pre>">    function call_func_addr_sample() : result type int {
         var clbk_p type int;
         $clbk_p = hefesto.sys.get_func_addr("abc_one_two_three");
         result hefesto.sys.call_from_addr($clbk_p, "abc", 1, "two", 3);
    }
</code></pre><h3 id="the-*list*-and-*string*-conveniences"><a name="the-*list*-and-*string*-conveniences" href="#the-*list*-and-*string*-conveniences"></a>The <em>list</em> and <em>string</em> conveniences</h3><p>Maybe at first glance you would call these conveniences as methods. However, the <code>HSL</code> is not a class-based Programming Language. Due to it, these “methods”<br>are only conveniences related with common operations which can be performed over these related types (list, string).</p><p>The <strong>Table 5</strong> gathers a listing about the conveniences related with the <code>string</code> type. The <strong>Table 6</strong> gathers the conveniences related with the <code>list</code><br>type.</p><p><strong>Table 5</strong>: The <code>string-type</code> conveniences.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Convenience</strong></th>
<th style="text-align:right"><strong>Handy for</strong></th>
<th style="text-align:center"><strong>Usage sample</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>at</code></td>
<td style="text-align:right">Returning the current <em>byte</em> under the passed index</td>
<td style="text-align:center">$str.at(0)</td>
</tr>
<tr>
<td style="text-align:center"><code>len</code></td>
<td style="text-align:right">Returning the <em>string</em> length</td>
<td style="text-align:center">$str.len()</td>
</tr>
<tr>
<td style="text-align:center"><code>match</code></td>
<td style="text-align:right">Searching a pattern onto the string data using a passed regular expression</td>
<td style="text-align:center">$str.match(“.*”)</td>
</tr>
<tr>
<td style="text-align:center"><code>replace</code></td>
<td style="text-align:right">Replacing a pattern onto the string data using a passed regular expression</td>
<td style="text-align:center">$str.replace(“.*”, “nothing”)</td>
</tr>
</tbody>
</table><p><strong>Table 6</strong>: The <code>list-type</code> conveniences.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Convenience</strong></th>
<th style="text-align:right"><strong>Handy for</strong></th>
<th style="text-align:center"><strong>Usage sample</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>item</code></td>
<td style="text-align:right">Returning the item under the passed index</td>
<td style="text-align:center">$lst.item(0)</td>
</tr>
<tr>
<td style="text-align:center"><code>count</code></td>
<td style="text-align:right">Returning the current items total count</td>
<td style="text-align:center">$lst.count()</td>
</tr>
<tr>
<td style="text-align:center"><code>add_item</code></td>
<td style="text-align:right">Adding a new passed item into the related list</td>
<td style="text-align:center">$lst.add_item(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>del_item</code></td>
<td style="text-align:right">Removing the first occurrence of the passed item</td>
<td style="text-align:center">$lst.del_item(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>del_index</code></td>
<td style="text-align:right">Removing the item under the passed index</td>
<td style="text-align:center">$lst.del_index(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ls</code></td>
<td style="text-align:right">Loading the file paths which match with the passed regular expression</td>
<td style="text-align:center">$lst.ls(“.*\\.c$”)</td>
</tr>
<tr>
<td style="text-align:center"><code>clear</code></td>
<td style="text-align:right">Cleaning up the list removing all its items</td>
<td style="text-align:center">$lst.clear()</td>
</tr>
<tr>
<td style="text-align:center"><code>index_of</code></td>
<td style="text-align:right">Returning the index which are equals to the passed item otherwise <code>-1</code></td>
<td style="text-align:center">$lst.index_of(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>swap</code></td>
<td style="text-align:right">Swapping the position of two passed indexes</td>
<td style="text-align:center">$lst.swap(0,9)</td>
</tr>
</tbody>
</table><h4 id="using-samples-of-these-conveniences"><a name="using-samples-of-these-conveniences" href="#using-samples-of-these-conveniences"></a>Using samples of these conveniences</h4><p>Here follows:</p><pre><code data-origin="<pre><code>function get_filepaths_from_directories(dir type list, regex type string) :
                                                            return type list {
    var d type int;
    var dirpath type string;
    var oldcwd type string;
    var retval type list;
    $oldcwd = hefesto.sys.pwd();
    $d = 0;
    while ($d &amp;lt; $dir.count()) {
        $dirpath = $dir.item($d);
        if (hefesto.sys.cd($dirpath) == 1) {
            $retval.ls($regex);
        }
        $d = $d + 1;
    }
    hefesto.sys.cd($oldcwd);
    result $retval;
}
</code></pre>">function get_filepaths_from_directories(dir type list, regex type string) :
                                                            return type list {
    var d type int;
    var dirpath type string;
    var oldcwd type string;
    var retval type list;
    $oldcwd = hefesto.sys.pwd();
    $d = 0;
    while ($d &lt; $dir.count()) {
        $dirpath = $dir.item($d);
        if (hefesto.sys.cd($dirpath) == 1) {
            $retval.ls($regex);
        }
        $d = $d + 1;
    }
    hefesto.sys.cd($oldcwd);
    result $retval;
}
</code></pre><p>How to use:</p><blockquote>
<p><code>var dir type list;</code></p>
<p><code>var os_name type string;</code></p>
<p><code>$os_name = hefesto.sys.os_name();</code></p>
<p><code>$dir.add_item(".");</code></p>
<p><code>$dir.add_item("native/" + $os_name);</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/fs");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/net");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/mm");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/ps");</code></p>
<p><code>$dir.add_item("common/");</code></p>
<p><code>$dir.add_item("common/fs");</code></p>
<p><code>$dir.add_item("common/net");</code></p>
<p><code>$dir.add_item("common/mm");</code></p>
<p><code>$dir.add_item("common/ps");</code></p>
<p><code>var files type list;</code></p>
<p><code>$files = get_filepaths_from_directories($dir, "*.\\.c$");</code></p>
</blockquote><pre><code data-origin="<pre><code>function piglatinize(said type string) : result type string {
    var s type int;
    var etvalray type string;
    var punctoken type list;
    var curr_symbol type string;
    var curr_word type string;

    if ($said.match(&quot;[0123456789]&quot;) == 1) {
        hefesto.sys.echo(&quot;ANICPAY: I can't handle numbers... aieeeeeeee!!\n&quot;);
        result &quot;(ullnay)&quot;; # no way: &quot;nil&quot; is not piglatin!!!! :D
    }

    $punctoken.add_item(&quot; &quot;);
    $punctoken.add_item(&quot;,&quot;);
    $punctoken.add_item(&quot;;&quot;);
    $punctoken.add_item(&quot;.&quot;);
    $punctoken.add_item(&quot;?&quot;);
    $punctoken.add_item(&quot;!&quot;);
    $s = 0;
    while ($s &amp;lt; $said.len()) {
        $curr_symbol = $said.at($s);
        if (($s + 1) == $said.len()) {
            if ($punctoken.index_of($curr_symbol) == -1) {
                $curr_word = $curr_word + $curr_symbol;
                $curr_symbol = &quot;.&quot;;
            }
        }
        if ($punctoken.index_of($curr_symbol) &amp;gt; -1) {
            if ($curr_word.len() &amp;gt; 1) {
                var first_letter type string;
                var second_letter type string;
                $first_letter = $curr_word.at(0);
                $second_letter = $curr_word.at(1);
                var ss type int;
                $ss = 2;
                $etvalray = $etvalray + $second_letter;
                while ($ss &amp;lt; $curr_word.len()) {
                    $etvalray = $etvalray + $curr_word.at($ss);
                    $ss = $ss + 1;
                }
                $etvalray = $etvalray + tolower($first_letter);
            } else {}
                $etvalray = $etvalray + $curr_word;
            }
            if ($curr_word.len() &amp;gt; 0) {
                $etvalray = $etvalray + &quot;ay&quot;;
            }
            $etvalray = $etvalray + $curr_symbol;
            $curr_word = &quot;&quot;;
        } else {
            $curr_word = $curr_word + $said.at($s);
        }
        $s = $s + 1;
    }
    result $etvalray;
}

function tolower(l type string) : result type string {
    var letters type list;
    $letters.add_item(&quot;A&quot;);
    $letters.add_item(&quot;B&quot;);
    $letters.add_item(&quot;C&quot;);
    $letters.add_item(&quot;D&quot;);
    $letters.add_item(&quot;E&quot;);
    $letters.add_item(&quot;F&quot;);
    $letters.add_item(&quot;G&quot;);
    $letters.add_item(&quot;H&quot;);
    $letters.add_item(&quot;I&quot;);
    $letters.add_item(&quot;K&quot;);
    $letters.add_item(&quot;K&quot;);
    $letters.add_item(&quot;L&quot;);
    $letters.add_item(&quot;M&quot;);
    $letters.add_item(&quot;N&quot;);
    $letters.add_item(&quot;O&quot;);
    $letters.add_item(&quot;P&quot;);
    $letters.add_item(&quot;Q&quot;);
    $letters.add_item(&quot;R&quot;);
    $letters.add_item(&quot;S&quot;);
    $letters.add_item(&quot;T&quot;);
    $letters.add_item(&quot;U&quot;);
    $letters.add_item(&quot;V&quot;);
    $letters.add_item(&quot;W&quot;);
    $letters.add_item(&quot;X&quot;);
    $letters.add_item(&quot;Y&quot;);
    $letters.add_item(&quot;Z&quot;);
    $letters.add_item(&quot;a&quot;);
    $letters.add_item(&quot;b&quot;);
    $letters.add_item(&quot;c&quot;);
    $letters.add_item(&quot;d&quot;);
    $letters.add_item(&quot;e&quot;);
    $letters.add_item(&quot;f&quot;);
    $letters.add_item(&quot;g&quot;);
    $letters.add_item(&quot;h&quot;);
    $letters.add_item(&quot;i&quot;);
    $letters.add_item(&quot;j&quot;);
    $letters.add_item(&quot;k&quot;);
    $letters.add_item(&quot;l&quot;);
    $letters.add_item(&quot;m&quot;);
    $letters.add_item(&quot;n&quot;);
    $letters.add_item(&quot;o&quot;);
    $letters.add_item(&quot;p&quot;);
    $letters.add_item(&quot;q&quot;);
    $letters.add_item(&quot;r&quot;);
    $letters.add_item(&quot;s&quot;);
    $letters.add_item(&quot;t&quot;);
    $letters.add_item(&quot;u&quot;);
    $letters.add_item(&quot;v&quot;);
    $letters.add_item(&quot;w&quot;);
    $letters.add_item(&quot;x&quot;);
    $letters.add_item(&quot;y&quot;);
    $letters.add_item(&quot;z&quot;);
    var l_index type int;
    $l_index =  $letters.index_of($l);
    if ($l_index &amp;gt; -1 &amp;amp;&amp;amp; $l_index &amp;lt; 26) {
        var lower_letter type string;
        $lower_letter = $letters.item($l_index + 26);
        result $lower_letter;
    }
    result $l;
}
</code></pre>">function piglatinize(said type string) : result type string {
    var s type int;
    var etvalray type string;
    var punctoken type list;
    var curr_symbol type string;
    var curr_word type string;

    if ($said.match("[0123456789]") == 1) {
        hefesto.sys.echo("ANICPAY: I can't handle numbers... aieeeeeeee!!\n");
        result "(ullnay)"; # no way: "nil" is not piglatin!!!! :D
    }

    $punctoken.add_item(" ");
    $punctoken.add_item(",");
    $punctoken.add_item(";");
    $punctoken.add_item(".");
    $punctoken.add_item("?");
    $punctoken.add_item("!");
    $s = 0;
    while ($s &lt; $said.len()) {
        $curr_symbol = $said.at($s);
        if (($s + 1) == $said.len()) {
            if ($punctoken.index_of($curr_symbol) == -1) {
                $curr_word = $curr_word + $curr_symbol;
                $curr_symbol = ".";
            }
        }
        if ($punctoken.index_of($curr_symbol) &gt; -1) {
            if ($curr_word.len() &gt; 1) {
                var first_letter type string;
                var second_letter type string;
                $first_letter = $curr_word.at(0);
                $second_letter = $curr_word.at(1);
                var ss type int;
                $ss = 2;
                $etvalray = $etvalray + $second_letter;
                while ($ss &lt; $curr_word.len()) {
                    $etvalray = $etvalray + $curr_word.at($ss);
                    $ss = $ss + 1;
                }
                $etvalray = $etvalray + tolower($first_letter);
            } else {}
                $etvalray = $etvalray + $curr_word;
            }
            if ($curr_word.len() &gt; 0) {
                $etvalray = $etvalray + "ay";
            }
            $etvalray = $etvalray + $curr_symbol;
            $curr_word = "";
        } else {
            $curr_word = $curr_word + $said.at($s);
        }
        $s = $s + 1;
    }
    result $etvalray;
}

function tolower(l type string) : result type string {
    var letters type list;
    $letters.add_item("A");
    $letters.add_item("B");
    $letters.add_item("C");
    $letters.add_item("D");
    $letters.add_item("E");
    $letters.add_item("F");
    $letters.add_item("G");
    $letters.add_item("H");
    $letters.add_item("I");
    $letters.add_item("K");
    $letters.add_item("K");
    $letters.add_item("L");
    $letters.add_item("M");
    $letters.add_item("N");
    $letters.add_item("O");
    $letters.add_item("P");
    $letters.add_item("Q");
    $letters.add_item("R");
    $letters.add_item("S");
    $letters.add_item("T");
    $letters.add_item("U");
    $letters.add_item("V");
    $letters.add_item("W");
    $letters.add_item("X");
    $letters.add_item("Y");
    $letters.add_item("Z");
    $letters.add_item("a");
    $letters.add_item("b");
    $letters.add_item("c");
    $letters.add_item("d");
    $letters.add_item("e");
    $letters.add_item("f");
    $letters.add_item("g");
    $letters.add_item("h");
    $letters.add_item("i");
    $letters.add_item("j");
    $letters.add_item("k");
    $letters.add_item("l");
    $letters.add_item("m");
    $letters.add_item("n");
    $letters.add_item("o");
    $letters.add_item("p");
    $letters.add_item("q");
    $letters.add_item("r");
    $letters.add_item("s");
    $letters.add_item("t");
    $letters.add_item("u");
    $letters.add_item("v");
    $letters.add_item("w");
    $letters.add_item("x");
    $letters.add_item("y");
    $letters.add_item("z");
    var l_index type int;
    $l_index =  $letters.index_of($l);
    if ($l_index &gt; -1 &amp;&amp; $l_index &lt; 26) {
        var lower_letter type string;
        $lower_letter = $letters.item($l_index + 26);
        result $lower_letter;
    }
    result $l;
}
</code></pre><p>Should be used on this way:</p><blockquote>
<p><code>hefesto.sys.echo(piglatinize("I like to speak pig latin.") + "\n");</code></p>
</blockquote><h3 id="the-*project*-sub-system"><a name="the-*project*-sub-system" href="#the-*project*-sub-system"></a>The <em>project</em> sub-system</h3><p>This sub-system gathers relavant data about the current executed forge project. It can be accessed any time from everywhere into the forge.</p><p>The functions shown by the <strong>Table 7</strong> can be accessed in the following general form:</p><blockquote>
<p><code>hefesto.project.&lt;function-name&gt;(&lt;args&gt;)</code></p>
</blockquote><p><strong>Table 7</strong>: Implemented functions from the <code>project</code> sub-system until now.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Function</strong></th>
<th style="text-align:right"><strong>Handy for</strong></th>
<th style="text-align:right"><strong>Calling sample</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>name()</code></td>
<td style="text-align:right">Returning the name of the current executed project</td>
<td style="text-align:right"><code>hefesto.project.name()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>toolset()</code></td>
<td style="text-align:right">Returning the name of the picked toolset</td>
<td style="text-align:right"><code>hefesto.project.toolset()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>dep_chain()</code></td>
<td style="text-align:right">Returning the content of the used <code>dep-chain</code></td>
<td style="text-align:right"><code>hefesto.project.dep_chain()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>abort()</code></td>
<td style="text-align:right">Aborting the executed project</td>
<td style="text-align:right"><code>hefesto.project.abort(1)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>cmdline()</code></td>
<td style="text-align:right">Returning the command line which the forge is based on</td>
<td style="text-align:right"><code>hefesto.project.cmdline()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>file_path()</code></td>
<td style="text-align:right">Returning the <code>file path</code> of the file where the executed project was defined</td>
<td style="text-align:right"><code>hefesto.project.file_path()</code></td>
</tr>
</tbody>
</table><h3 id="is-there-an-easy-way-of-running-these-samples-for-playing-with-the-language?"><a name="is-there-an-easy-way-of-running-these-samples-for-playing-with-the-language?" href="#is-there-an-easy-way-of-running-these-samples-for-playing-with-the-language?"></a>Is there an easy way of running these samples for playing with the Language?</h3><p>Yes, sure! When you install <code>Hefesto</code> together are installed a <a href="https://github.com/rafael-santiago/helios/blob/master/src/include/doc/toolsets/null/README.md">stub</a> <code>toolset</code>.<br>When basing a project on this stub toolset you can call anything from inside the <code>project entry points</code>.</p><h3 id="where-can-i-continue-exploring-the-*hsl*?"><a name="where-can-i-continue-exploring-the-*hsl*?" href="#where-can-i-continue-exploring-the-*hsl*?"></a>Where can I continue exploring the <em>HSL</em>?</h3><p>The <code>HSL</code> has its on repository gathering useful stuff. It is called <a href="https://github.com/rafael-santiago/helios.git">Helios</a>. When you clone the <code>Hesfesto's</code> repo<br>the <code>Helios</code> is also cloned together (as a git-submodule). By the way, a very basic piece from Helios is installed on. By default, Helios includes documentation about its modules.<br>Take a look at this documentation, it is a good thing to do before using any additional <code>Hefesto</code> stuff. </p><p>You can also understand <code>Helios</code> as a <code>Hefesto</code> package manager or still as the <code>Hefesto include</code> directory.</p><p>There is a code collection inside <code>Helios</code> called <a href="https://github.com/rafael-santiago/helios/blob/master/src/include/doc/hc/README.md">hc-functions</a>.<br>Using the <code>hc-functions</code> is possible to perform several checkings over a current build environment. It is good for using when you want to check if the<br>environment really can build your software. It can verify software exportation, library version, etc. All is done using straightforward <code>HSL</code> functions<br>which can be re-used, improved, extended, etc.</p><h3 id="creating-*hefesto-toolsets*-and-completely-mastering-the-discussed-*build-system*"><a name="creating-*hefesto-toolsets*-and-completely-mastering-the-discussed-*build-system*" href="#creating-*hefesto-toolsets*-and-completely-mastering-the-discussed-*build-system*"></a>Creating <em>Hefesto toolsets</em> and completely mastering the discussed <em>build system</em></h3><p>If have read the prior sections and tried to run the samples, there is a last step for becoming an “advanced Hefesto user”. Until the now you know how to<br>automate pre/post steps on your <em>build-task</em> besides using the “from-factory-toolsets”. Then you still are final user here being dependant from another<br><a href="http://en.wikipedia.org/wiki/Tasmanian_Devil_(Looney_Tunes"><code>toolset devel</code></a>).</p><p>For this reason, I invite you to learn how to implement a <code>Hefesto toolset</code> from scrath.</p><h3 id="before-starting:-a-short-overview-about-everything-already-seen"><a name="before-starting:-a-short-overview-about-everything-already-seen" href="#before-starting:-a-short-overview-about-everything-already-seen"></a>Before starting: a short overview about everything already seen</h3><p>Things that you already know:</p><ul>
<li>The <code>Hefesto</code> is a <em>build system</em> that seeks tidiness during the build-task writing.</li><li>It implements a <em>dsl</em> that is used on the extensions (single user requirements) besides on the general requirements for building something (toolsets).</li><li>The <code>HSL</code> portion related with the user projects declaration have shown.</li><li>Also was shown the ways how to run a <em>build</em> (forge).</li><li>You have seen how to watch for changes onto files which compose your code base.</li><li>A overview (user context) about <code>dep-chain</code> was introduced.</li><li>Was shown how to include additinal steps into a build task, an example about running unit tests, after evaluating its result was detailed.</li><li>The possibility of creating a more adaptable <em>Forgefile</em> such the toolset selection occurs at run-time was shown.</li><li>General aspects about the <code>HSL</code> and its sub-system <code>sys</code> was detailed.</li></ul><p>What you still do not know but after reading the following sections will can master:</p><ul>
<li>How to declare a <code>toolset</code>.</li><li>The <code>toolset</code> sub-system.</li><li>How does Hefesto (internally) detects that a file was changed.</li><li>The <code>project</code> sub-system.</li><li>Good practices for creating and maintaining new <code>toolsets</code>.</li></ul><h4 id="our-goal:-a-*gcc*-toolset-for-compiling-and-generating-applications-written-in-*c*"><a name="our-goal:-a-*gcc*-toolset-for-compiling-and-generating-applications-written-in-*c*" href="#our-goal:-a-*gcc*-toolset-for-compiling-and-generating-applications-written-in-*c*"></a>Our goal: a <em>GCC</em> toolset for compiling and generating applications written in <em>C</em></h4><p>I picked the <em>C</em> Language because it is a “compiled based language”. It involves dependencies that must be resolved externally from the compiler. Nowadays,<br>the new Languages brings a bunch of “candy-plushy-wheels” for compiling our codes. The <em>C</em> Language makes you thing more about what really is to compile a<br>code. So, we will use it for your “fire baptism”. After this, any survivor will rush to automate a bunch of tasks, now pretty easy when compared with this<br>“complicated” C toolset. Are you ready, dear (who knows) suvivor? Bitter medicine is better to drink fast… So, let’s go!</p><h4 id="figuring-out-who-depends-on-who"><a name="figuring-out-who-depends-on-who" href="#figuring-out-who-depends-on-who"></a>Figuring out who depends on who</h4><p>Yes, a good notion about <em>C</em> would be nice here. Even newbie. For this section I am taking in consideration C Newbie readers, okay? Do not be offended, your damn <em>C</em> guru.</p><p>Supposing that we have the following <em>C</em> <code>main</code> function:</p><pre><code data-origin="<pre><code>    #include &quot;init.h&quot;
    #include &quot;config.h&quot;
    #include &quot;options.h&quot;
    #include &amp;lt;stdio.h&amp;gt;

    int main(int argc, char **argv) {
        if (argc &amp;gt; 1) {
            get_options(argv, argc);
        }
        if (do_config()) {
            printf(&quot;*** Started!\n&quot;);
            return init();
        }
        printf(&quot;*** Error.\n&quot;);
        return 1;
    }
</code></pre>">    #include "init.h"
    #include "config.h"
    #include "options.h"
    #include &lt;stdio.h&gt;

    int main(int argc, char **argv) {
        if (argc &gt; 1) {
            get_options(argv, argc);
        }
        if (do_config()) {
            printf("*** Started!\n");
            return init();
        }
        printf("*** Error.\n");
        return 1;
    }
</code></pre><p>In <em>C</em> a include is a little clue telling us about “the doomed mystery of the forgotten dependencies”. Usually, inclusions done using double quotes are about local<br>files (a.k.a. dependencies), opposing to <code>&lt; ... &gt;</code> which are about external dependencies.</p><p>From now on, we will compose a function that will figure out and spit for us a <code>dep-chain</code> from any <em>C</em> project written using these standard <code>include</code> “modus-operandi”.</p><p>How is the best way for serializing into lines a file content under the <code>HSL</code>? I vote for the syscall <code>lines_from_file()</code>. I will show the entire code<br>for commenting the interesting parts later:</p><pre><code data-origin="<pre><code>include ~/fsutil.hsl

function get_c_cpp_deps() : result type string {
    var files type list;
    var includes type list;
    var f type int;
    var i type int;
    var dep_chain type string;
    var str type string;
    var cwd type string;
    var exts type list;
    var e type int;
    var dep_nr type int;
    var related_files type list;

    $e = 0;

    $exts.add_item(&quot;h&quot;);
    $exts.add_item(&quot;hpp&quot;);
    $exts.add_item(&quot;c&quot;);
    $exts.add_item(&quot;C&quot;);
    $exts.add_item(&quot;CC&quot;);
    $exts.add_item(&quot;cc&quot;);
    $exts.add_item(&quot;cpp&quot;);
    $exts.add_item(&quot;CPP&quot;);

    while ($e &amp;lt; $exts.count()) {
        $str = &quot;.*\\.&quot; + $exts.item($e) + &quot;@@bodyquot;;
        $files.ls($str);
        $f = 0;
        $cwd = hefesto.sys.pwd();
        while ($f &amp;lt; $files.count()) {
            $str = $files.item($f);
            $dep_chain = $dep_chain + $str + &quot;: &quot;;
            $includes = hefesto.sys.lines_from_file($str, &quot;#include.*@@bodyquot;);
            $i = 0;
            $dep_nr = 0;
            while ($i &amp;lt; $includes.count()) {
                $str = $includes.item($i);
                $str.replace(&quot;.*#include.*(\&quot;|&amp;lt;)&quot;, &quot;&quot;);
                $str.replace(&quot;(\&quot;|&amp;gt;)@@bodyquot;, &quot;&quot;);
                if (isfile($str) == 1) {
                    $str = hefesto.sys.make_path($cwd, $str);
                    if ($dep_nr &amp;gt; 0) {
                        $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
                    }
                    $dep_chain = $dep_chain + $str + &quot; &quot;;
                    $dep_nr = $dep_nr + 1;
                    }
                $i = $i + 1;
            }
            if ($exts.item($e) == &quot;h&quot; || $exts.item($e) == &quot;hpp&quot;) {
                $str = $files.item($f);
                $str = filenamefrompath($str);
                $str.replace(&quot;\\.(h|hpp)@@bodyquot;, &quot;&quot;);
                $related_files.clear();
                $related_files.ls(&quot;.*&quot; + filenamefrompath($str) + &quot;\\.(c|C|CC|cc|cpp|CPP)@@bodyquot;);
                if ($related_files.count() &amp;gt; 0) {
                    $i = 0;
                    while ($i &amp;lt; $related_files.count()) {
                        if ($dep_nr &amp;gt; 0) {
                            $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
                        }
                        $dep_chain = $dep_chain + $related_files.item($i) + &quot; &quot;;
                        $dep_nr = $dep_nr + 1;
                        $i = $i + 1;
                    }
                }
            }
            $dep_chain = $dep_chain + &quot;;\n&quot;;
            $f = $f + 1;
        }
        $files.clear();
        $e = $e + 1;
    }
    result $dep_chain;
}
</code></pre>">include ~/fsutil.hsl

function get_c_cpp_deps() : result type string {
    var files type list;
    var includes type list;
    var f type int;
    var i type int;
    var dep_chain type string;
    var str type string;
    var cwd type string;
    var exts type list;
    var e type int;
    var dep_nr type int;
    var related_files type list;

    $e = 0;

    $exts.add_item("h");
    $exts.add_item("hpp");
    $exts.add_item("c");
    $exts.add_item("C");
    $exts.add_item("CC");
    $exts.add_item("cc");
    $exts.add_item("cpp");
    $exts.add_item("CPP");

    while ($e &lt; $exts.count()) {
        $str = ".*\\." + $exts.item($e) + "$";
        $files.ls($str);
        $f = 0;
        $cwd = hefesto.sys.pwd();
        while ($f &lt; $files.count()) {
            $str = $files.item($f);
            $dep_chain = $dep_chain + $str + ": ";
            $includes = hefesto.sys.lines_from_file($str, "#include.*$");
            $i = 0;
            $dep_nr = 0;
            while ($i &lt; $includes.count()) {
                $str = $includes.item($i);
                $str.replace(".*#include.*(\"|&lt;)", "");
                $str.replace("(\"|&gt;)$", "");
                if (isfile($str) == 1) {
                    $str = hefesto.sys.make_path($cwd, $str);
                    if ($dep_nr &gt; 0) {
                        $dep_chain = $dep_chain + "&amp; ";
                    }
                    $dep_chain = $dep_chain + $str + " ";
                    $dep_nr = $dep_nr + 1;
                    }
                $i = $i + 1;
            }
            if ($exts.item($e) == "h" || $exts.item($e) == "hpp") {
                $str = $files.item($f);
                $str = filenamefrompath($str);
                $str.replace("\\.(h|hpp)$", "");
                $related_files.clear();
                $related_files.ls(".*" + filenamefrompath($str) + "\\.(c|C|CC|cc|cpp|CPP)$");
                if ($related_files.count() &gt; 0) {
                    $i = 0;
                    while ($i &lt; $related_files.count()) {
                        if ($dep_nr &gt; 0) {
                            $dep_chain = $dep_chain + "&amp; ";
                        }
                        $dep_chain = $dep_chain + $related_files.item($i) + " ";
                        $dep_nr = $dep_nr + 1;
                        $i = $i + 1;
                    }
                }
            }
            $dep_chain = $dep_chain + ";\n";
            $f = $f + 1;
        }
        $files.clear();
        $e = $e + 1;
    }
    result $dep_chain;
}
</code></pre><p>Yes, <em>parser</em> is a hard thing to code. Even silly at first glance, it can become a nightmare. All because it is about supporting lovely Human features: confusion,<br>untidiness, lack of pattern.</p><p>The lines:</p><pre><code data-origin="<pre><code>    $exts.add_item(&quot;h&quot;);
    $exts.add_item(&quot;hpp&quot;);
    $exts.add_item(&quot;c&quot;);
    $exts.add_item(&quot;C&quot;);
    $exts.add_item(&quot;CC&quot;);
    $exts.add_item(&quot;cc&quot;);
    $exts.add_item(&quot;cpp&quot;);
    $exts.add_item(&quot;CPP&quot;);
</code></pre>">    $exts.add_item("h");
    $exts.add_item("hpp");
    $exts.add_item("c");
    $exts.add_item("C");
    $exts.add_item("CC");
    $exts.add_item("cc");
    $exts.add_item("cpp");
    $exts.add_item("CPP");
</code></pre><p>Are the lines responsible for defining the relevant extensions for being scanned. Also is possible to eliminate the case issue, if you prefer doing it, feel free about.</p><p>After the lines shown above, each registered extension is used for composing a regular expression:</p><pre><code data-origin="<pre><code>$str = &quot;.*\\.&quot; + $exts.item($e) + &quot;@@bodyquot;;
</code></pre>">$str = ".*\\." + $exts.item($e) + "$";
</code></pre><p>Beyond the iterations it could be:</p><blockquote>
<p>“.*\\.h$”…</p>
<blockquote>
<p>“.*\\.hpp$”…</p>
<blockquote>
<p>“.*\\.c$”…</p>
<blockquote>
<p>“.*\\.C$”…</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote><p>Thus, we will find the relevant files. Each found file will have registered into the <code>dep-chain</code> (followin the previous syntax presented, do you remember?).<br>On this way, Hefesto will be able to watch for this file:</p><pre><code data-origin="<pre><code>$str = $files.item($f);
$dep_chain = $dep_chain + $str + &quot;: &quot;;
</code></pre>">$str = $files.item($f);
$dep_chain = $dep_chain + $str + ": ";
</code></pre><p>After we look inside this found file, search for more dependencies. For doing it we use a pretty simple but handy regular expression:</p><pre><code data-origin="<pre><code>$includes = hefesto.sys.lines_from_file($str, &quot;#include.*@@bodyquot;);
</code></pre>">$includes = hefesto.sys.lines_from_file($str, "#include.*$");
</code></pre><p>Okay, “Why did not you use a anchor in this regex?”. Because, the funny &amp; lovely Human features, like:</p><blockquote>
<pre><code data-origin="<pre><code> #includes &quot;here.h&quot;
          #include &quot;there.h&quot;
   /*let's include over yonder too*/ #include &quot;over_yonder.h&quot;
</code></pre>"> #includes "here.h"
          #include "there.h"
   /*let's include over yonder too*/ #include "over_yonder.h"
</code></pre></blockquote><p>From each found line is extracted file <code>file name</code> and made a <code>full path</code> based on the <a href="http://en.wikipedia.org/wiki/Working_directory"><code>cwd</code></a>. If the<br>current file is really accessible under the <code>cwd</code> it is included as a dependency for the previous found file.</p><pre><code data-origin="<pre><code>while ($i &amp;lt; $includes.count()) {
    $str = $includes.item($i);
       $str.replace(&quot;.*#include.*(\&quot;|&amp;lt;)&quot;, &quot;&quot;);
       $str.replace(&quot;(\&quot;|&amp;gt;)@@bodyquot;, &quot;&quot;);
       if (isfile($str) == 1) {
           $str = hefesto.sys.make_path($cwd, $str);
        if ($dep_nr &amp;gt; 0) {
            $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
        }
        $dep_chain = $dep_chain + $str + &quot; &quot;;
        $dep_nr = $dep_nr + 1;
    }
    $i = $i + 1;
}
</code></pre>">while ($i &lt; $includes.count()) {
    $str = $includes.item($i);
       $str.replace(".*#include.*(\"|&lt;)", "");
       $str.replace("(\"|&gt;)$", "");
       if (isfile($str) == 1) {
           $str = hefesto.sys.make_path($cwd, $str);
        if ($dep_nr &gt; 0) {
            $dep_chain = $dep_chain + "&amp; ";
        }
        $dep_chain = $dep_chain + $str + " ";
        $dep_nr = $dep_nr + 1;
    }
    $i = $i + 1;
}
</code></pre><p>For each found <code>header</code> is applied a secondary search. This search is based on their implementation files: Same name exception the extension. When accessible<br>under the <code>cwd</code> an implementation file is also taken as a dependency and added to the <code>dep-chain</code>:</p><pre><code data-origin="<pre><code>if ($exts.item($e) == &quot;h&quot; || $exts.item($e) == &quot;hpp&quot;) {
    $str = $files.item($f);
    $str = filenamefrompath($str);
    $str.replace(&quot;\\.(h|hpp)@@bodyquot;, &quot;&quot;);
    $related_files.clear();
    $related_files.ls(&quot;.*&quot; + filenamefrompath($str) + &quot;\\.(c|C|CC|cc|cpp|CPP)@@bodyquot;);
    if ($related_files.count() &amp;gt; 0) {
        $i = 0;
        while ($i &amp;lt; $related_files.count()) {
            if ($dep_nr &amp;gt; 0) {
                $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
            }
            $dep_chain = $dep_chain + $related_files.item($i) + &quot; &quot;;
            $dep_nr = $dep_nr + 1;
            $i = $i + 1;
        }
    }
}
</code></pre>">if ($exts.item($e) == "h" || $exts.item($e) == "hpp") {
    $str = $files.item($f);
    $str = filenamefrompath($str);
    $str.replace("\\.(h|hpp)$", "");
    $related_files.clear();
    $related_files.ls(".*" + filenamefrompath($str) + "\\.(c|C|CC|cc|cpp|CPP)$");
    if ($related_files.count() &gt; 0) {
        $i = 0;
        while ($i &lt; $related_files.count()) {
            if ($dep_nr &gt; 0) {
                $dep_chain = $dep_chain + "&amp; ";
            }
            $dep_chain = $dep_chain + $related_files.item($i) + " ";
            $dep_nr = $dep_nr + 1;
            $i = $i + 1;
        }
    }
}
</code></pre><p>After this the current file will have all direct dependency scanned into the <code>dep-chain</code>. Being necessary only terminate the stream of dependencies for the<br>current found file:</p><pre><code data-origin="<pre><code>$dep_chain = $dep_chain + &quot;;\n&quot;;
</code></pre>">$dep_chain = $dep_chain + ";\n";
</code></pre><p>All that was described is repeated for each relevant file laying on the <code>cwd</code>.  You can change the <code>cwd</code> before calling the <code>c dependency-scanner</code>.<br>For doing it you should use the <code>cd syscall</code>.</p><p>After processing all files the <code>dep-chain</code> is returned to the caller:</p><pre><code data-origin="<pre><code>result $dep_chain;
</code></pre>">result $dep_chain;
</code></pre><p>This content will be used onto the section <code>dependencies</code> of a project declaration.</p><h5 id="creating-a-toolset"><a name="creating-a-toolset" href="#creating-a-toolset"></a>Creating a toolset</h5><p>A <code>toolset</code> needs to be declared. On declaring it, we not only can define the name of it, but also we can generalize anything that need to be done using<br>external toolset.</p><p>What does a <em>C</em> toolset need to do using external tools?</p><ul>
<li>To compile codes.</li><li>To link the produced object files.</li></ul><p>Follows the related toolset:</p><pre><code data-origin="<pre><code>include ~/toolsets/gcc/forges/gcc_c_app_forge.hsl

toolset &quot;gcc-c-app&quot; forge function &quot;gcc_c_binary_forge&quot; :
    forge helpers &quot;gcc_compile_source_list&quot;,
                  &quot;gcc_link_ofiles&quot;, &quot;gcc_mk_app_compilation_command&quot;:
    command &quot;compile_r&quot;: SOURCE, OUTFILE, INCLUDES, CFLAGS &amp;lt;
        gcc -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &amp;gt;
    command &quot;compile_d&quot;: SOURCE, OUTFILE, INCLUDES, CFLAGS &amp;lt;
        gcc -g -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &amp;gt;
    command &quot;link_shared&quot;: APPNAME, OBJECTS, LIBRARIES, LDFLAGS &amp;lt;
        gcc -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &amp;gt;
    command &quot;link_static&quot;: APPNAME, OBJECTS, LIBRARIES, LDFLAGS &amp;lt;
        gcc -static -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &amp;gt;
$
</code></pre>">include ~/toolsets/gcc/forges/gcc_c_app_forge.hsl

toolset "gcc-c-app" forge function "gcc_c_binary_forge" :
    forge helpers "gcc_compile_source_list",
                  "gcc_link_ofiles", "gcc_mk_app_compilation_command":
    command "compile_r": SOURCE, OUTFILE, INCLUDES, CFLAGS &lt;
        gcc -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &gt;
    command "compile_d": SOURCE, OUTFILE, INCLUDES, CFLAGS &lt;
        gcc -g -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &gt;
    command "link_shared": APPNAME, OBJECTS, LIBRARIES, LDFLAGS &lt;
        gcc -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &gt;
    command "link_static": APPNAME, OBJECTS, LIBRARIES, LDFLAGS &lt;
        gcc -static -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &gt;
$
</code></pre><p>The basic syntax is:</p><blockquote>
<p><code>toolset &lt;string-name&gt; forge function &lt;hsl-function-name&gt; : [forge helpers &lt;helpers-list&gt;] : &lt;command-templates&gt; $</code></p>
</blockquote><p>In the shown example, the <code>toolset</code> is called: <code>gcc-c-app</code>. Its forge function is: <code>gcc_c_binary_forge</code>.<br>This explains the <code>include</code> directive, the file where this functions follows defined. The forge helpers are: <code>gcc_compile_list</code>,<br><code>gcc_link_ofiles</code> and <code>gcc_mk_compilation_command</code>. The toolset definition always ends with the “tape ending” symbol (<code>$</code>).</p><p>The implemented command templates are: <code>compile_r</code>, <code>compile_d</code>, <code>link_shared</code> and <code>link_static</code>. A template command is nothing more than<br>an abstraction which your <code>toolset</code> will assemble. The syntax is in form:</p><blockquote>
<p><code>command &lt;string-name&gt; : &lt;string-argument-list&gt; &lt; &lt;command-line template&gt; &gt;</code></p>
</blockquote><p>A command toolset <strong>always</strong> receives strings as arguments and also returns a single string based on the previous defined template.</p><p>There is a strict rule about the accesibility of this <code>toolset</code> commands:</p><blockquote>
<p>Only can be accessed by the forge function and its forge helpers.</p>
</blockquote><p>For accessing this commands you should use the <code>toolset sub-system</code>:</p><blockquote>
<p>(…)<br><code>$cmd = hefesto.toolset.compile_r($source_path, $outfile_path, $includes, $cflags);</code><br>(…)</p>
</blockquote><p>A good approach before starting creating any toolset is to ask yourself about how are the external commands relevant to be executed in<br>order to get all work done. This is the genesis of any toolset in my opinion :)</p><h5 id="the-forge-function"><a name="the-forge-function" href="#the-forge-function"></a>The forge function</h5><p>Maybe this is the hardest part to figure out. The forge function is the place where the main <em>build</em> logics must be coded. Taking in consideration that<br>the forge function steps must be generalized on a way that must be useful for any <code>toolset</code> user.</p><p>Follows the forge function, after this code listing I will comment the relevant parts:</p><pre><code data-origin="<pre><code>function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int {
    var exit_code type int;
    var includes type string;
    var cflags type string;
    var libraries type string;
    var ldflags type string;
    var objects type string;

    if ($SOURCES.count() == 0) {
        if (hefesto.project.toolset() == &quot;gcc-c-app&quot;) {
            $SOURCES.ls(&quot;.*\\.c@@bodyquot;);
        } else {
            $SOURCES.ls(&quot;.*\\.(cc|cpp|CC|Cpp|CPP)@@bodyquot;);
        }
    }

    if ($SOURCES.count() == 0) {
        hefesto.sys.echo(&quot;\t(empty source list)\n&quot;);
        result 1;
    }

    var obj_output_dir type list;
    var obj_dir type string;

    $obj_output_dir = hefesto.sys.get_option(&quot;obj-output-dir&quot;);
    if ($obj_output_dir.count() &amp;gt; 0) {
        $obj_dir = $obj_output_dir.item(0);
        mktree($obj_dir);
    } else {
        $obj_dir = hefesto.sys.pwd();
    }

    var bin_output_dir type list;
    var bin_output type string;

    $bin_output_dir = hefesto.sys.get_option(&quot;bin-output-dir&quot;);
    if ($bin_output_dir.count() &amp;gt; 0) {
        $bin_output = $bin_output_dir.item(0);
        mktree($bin_output);
        $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
    } else {
        $bin_output = $APPNAME;
    }

    $exit_code = 0;

    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES); 

    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options

    var cpu_arch type list;
    var chosen_arch type string;
    $cpu_arch = hefesto.sys.get_option(&quot;cpu-arch&quot;);
    $chosen_arch = &quot;&quot;;
    if ($cpu_arch.count() &amp;gt; 0) {
        $chosen_arch = $cpu_arch.item(0);
        if ($chosen_arch != &quot;32&quot; &amp;amp;&amp;amp; $chosen_arch != &quot;64&quot;) {
            hefesto.sys.echo(hefesto.project.toolset() +
                &quot; fatal error: invalid value for cpu-arch &quot; +
                &quot;option must be '32' or '64'.\n&quot;);
            result 1;
        }
        $cflags = $cflags + &quot; -m&quot; + $chosen_arch;
    }

    #  compiling...
    hefesto.sys.echo(&quot;*** compiling...\n&quot;);

    $exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
    if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;amp;&amp;amp; isfile($bin_output) == 0) {
        $gcc_c_project_forge_dirty_files_nr = 1;
    }

    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0 &amp;amp;&amp;amp; $exit_code == 0) {
        $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
        $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
        if ($chosen_arch.len() &amp;gt; 0) {
            $ldflags = $ldflags + &quot;-m&quot; + $chosen_arch;
        }
        $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
        #  linking...
        hefesto.sys.echo(&quot;*** now linking...\n\t*** waiting...\n&quot;);
        $exit_code = gcc_link_ofiles($objects,
                                     $libraries
                                     $ldflags,
                                     $bin_output);
    }

    if ($exit_code == 0) {
        hefesto.sys.echo(&quot;*** success.\n&quot;);
    } else {
        hefesto.sys.echo(&quot;*** failure.\n&quot;);
    }

    result $exit_code;
}
</code></pre>">function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int {
    var exit_code type int;
    var includes type string;
    var cflags type string;
    var libraries type string;
    var ldflags type string;
    var objects type string;

    if ($SOURCES.count() == 0) {
        if (hefesto.project.toolset() == "gcc-c-app") {
            $SOURCES.ls(".*\\.c$");
        } else {
            $SOURCES.ls(".*\\.(cc|cpp|CC|Cpp|CPP)$");
        }
    }

    if ($SOURCES.count() == 0) {
        hefesto.sys.echo("\t(empty source list)\n");
        result 1;
    }

    var obj_output_dir type list;
    var obj_dir type string;

    $obj_output_dir = hefesto.sys.get_option("obj-output-dir");
    if ($obj_output_dir.count() &gt; 0) {
        $obj_dir = $obj_output_dir.item(0);
        mktree($obj_dir);
    } else {
        $obj_dir = hefesto.sys.pwd();
    }

    var bin_output_dir type list;
    var bin_output type string;

    $bin_output_dir = hefesto.sys.get_option("bin-output-dir");
    if ($bin_output_dir.count() &gt; 0) {
        $bin_output = $bin_output_dir.item(0);
        mktree($bin_output);
        $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
    } else {
        $bin_output = $APPNAME;
    }

    $exit_code = 0;

    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES); 

    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options

    var cpu_arch type list;
    var chosen_arch type string;
    $cpu_arch = hefesto.sys.get_option("cpu-arch");
    $chosen_arch = "";
    if ($cpu_arch.count() &gt; 0) {
        $chosen_arch = $cpu_arch.item(0);
        if ($chosen_arch != "32" &amp;&amp; $chosen_arch != "64") {
            hefesto.sys.echo(hefesto.project.toolset() +
                " fatal error: invalid value for cpu-arch " +
                "option must be '32' or '64'.\n");
            result 1;
        }
        $cflags = $cflags + " -m" + $chosen_arch;
    }

    #  compiling...
    hefesto.sys.echo("*** compiling...\n");

    $exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
    if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;&amp; isfile($bin_output) == 0) {
        $gcc_c_project_forge_dirty_files_nr = 1;
    }

    if ($gcc_c_project_forge_dirty_files_nr &gt; 0 &amp;&amp; $exit_code == 0) {
        $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
        $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
        if ($chosen_arch.len() &gt; 0) {
            $ldflags = $ldflags + "-m" + $chosen_arch;
        }
        $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
        #  linking...
        hefesto.sys.echo("*** now linking...\n\t*** waiting...\n");
        $exit_code = gcc_link_ofiles($objects,
                                     $libraries
                                     $ldflags,
                                     $bin_output);
    }

    if ($exit_code == 0) {
        hefesto.sys.echo("*** success.\n");
    } else {
        hefesto.sys.echo("*** failure.\n");
    }

    result $exit_code;
}
</code></pre><p>The forge function has the following interface:</p><pre><code data-origin="<pre><code>function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int
</code></pre>">function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int
</code></pre><p>This interface explains the sequence and types of the passed arguments during a project declaration which uses the discussed <code>toolset</code>. Remembering:</p><pre><code data-origin="<pre><code>var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project sample : toolset &quot;gcc-c-app&quot; : $sources, $includes, $cflags,
                                       $libraries, $ldflags, &quot;sample&quot; ;
</code></pre>">var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project sample : toolset "gcc-c-app" : $sources, $includes, $cflags,
                                       $libraries, $ldflags, "sample" ;
</code></pre><p>At the beginning of the presented forge function code, we can see a convenience:</p><pre><code data-origin="<pre><code>if ($SOURCES.count() == 0) {
    if (hefesto.project.toolset() == &quot;gcc-c-app&quot;) {
        $SOURCES.ls(&quot;.*\\.c@@bodyquot;);
    } else {
        $SOURCES.ls(&quot;.*\\.(cc|cpp|CC|Cpp|CPP)@@bodyquot;);
    }
}
</code></pre>">if ($SOURCES.count() == 0) {
    if (hefesto.project.toolset() == "gcc-c-app") {
        $SOURCES.ls(".*\\.c$");
    } else {
        $SOURCES.ls(".*\\.(cc|cpp|CC|Cpp|CPP)$");
    }
}
</code></pre><p> If a empty source code list is passed, the forge function will try to scan code into the current working directory. This toolset is used for <code>C/C++</code> code<br> compiling, this explains the if clause based on the current chosen toolset name.</p><p> After this attempt, being <code>SOURCES</code> still empty:</p><pre><code data-origin="<pre><code> if ($SOURCES.count() == 0) {
    hefesto.sys.echo(&quot;\t(empty source list)\n&quot;);
    result 1;
}
</code></pre>"> if ($SOURCES.count() == 0) {
    hefesto.sys.echo("\t(empty source list)\n");
    result 1;
}
</code></pre><p>We finish here, informing the user about the impossibility of compiling something under this directory. The value <code>1</code> is returned to make the <code>Hefesto</code><br>“break” the forge process. In this case, it will catch the user’s attention about the related fact.</p><p>We have more conveniences… Sometimes we do not want to polute the project’s directory with files produced by the build process (object files, etc):</p><pre><code data-origin="<pre><code>var obj_output_dir type list;
var obj_dir type string;

$obj_output_dir = hefesto.sys.get_option(&quot;obj-output-dir&quot;);
if ($obj_output_dir.count() &amp;gt; 0) {
    $obj_dir = $obj_output_dir.item(0);
    mktree($obj_dir);
} else {
    $obj_dir = hefesto.sys.pwd();
}
</code></pre>">var obj_output_dir type list;
var obj_dir type string;

$obj_output_dir = hefesto.sys.get_option("obj-output-dir");
if ($obj_output_dir.count() &gt; 0) {
    $obj_dir = $obj_output_dir.item(0);
    mktree($obj_dir);
} else {
    $obj_dir = hefesto.sys.pwd();
}
</code></pre><p>If the user has passed the option <code>--obj-output-dir=&lt;dirpath&gt;</code> we will create and use the requested directory for putting object files there,<br>otherwise we will use the <code>cwd</code> as our object directory. The <code>syscall get_option</code> always returns a list. When something is passed into a requested<br>option, the list returned should contain at least one argument. The function <code>mktree()</code> is a function defined into <code>fsutil.hsl</code>, this function<br>creates a directory tree if it not exists.</p><p>A similar thing is done with the binary directory, take a look:</p><pre><code data-origin="<pre><code>$bin_output_dir = hefesto.sys.get_option(&quot;bin-output-dir&quot;);
if ($bin_output_dir.count() &amp;gt; 0) {
    $bin_output = $bin_output_dir.item(0);
    mktree($bin_output);
    $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
} else {
    $bin_output = $APPNAME;
}
</code></pre>">$bin_output_dir = hefesto.sys.get_option("bin-output-dir");
if ($bin_output_dir.count() &gt; 0) {
    $bin_output = $bin_output_dir.item(0);
    mktree($bin_output);
    $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
} else {
    $bin_output = $APPNAME;
}
</code></pre><p>Now it is the time of converting the compiler’s options expressed as lists into <em>strings</em>:</p><pre><code data-origin="<pre><code>    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES);
    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options
</code></pre>">    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES);
    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options
</code></pre><p>The referenced functions above, will be further detailed. By now, you can know them superficially without any problem.</p><p>It is a good convenience the possibility of choosing the <em>target’s</em> architecture. In this case, the option read by the code presented right below, allows<br>the choice of a <em>32-bit</em> or <em>64-bit</em> binary:</p><pre><code data-origin="<pre><code>var cpu_arch type list;
var chosen_arch type string;
$cpu_arch = hefesto.sys.get_option(&quot;cpu-arch&quot;);
$chosen_arch = &quot;&quot;;
if ($cpu_arch.count() &amp;gt; 0) {
    $chosen_arch = $cpu_arch.item(0);
    if ($chosen_arch != &quot;32&quot; &amp;amp;&amp;amp; $chosen_arch != &quot;64&quot;) {
        hefesto.sys.echo(hefesto.project.toolset() +
                &quot; fatal error: invalid value for cpu-arch &quot; +
                &quot;option must be '32' or '64'.\n&quot;);
        result 1;
    }
}
</code></pre>">var cpu_arch type list;
var chosen_arch type string;
$cpu_arch = hefesto.sys.get_option("cpu-arch");
$chosen_arch = "";
if ($cpu_arch.count() &gt; 0) {
    $chosen_arch = $cpu_arch.item(0);
    if ($chosen_arch != "32" &amp;&amp; $chosen_arch != "64") {
        hefesto.sys.echo(hefesto.project.toolset() +
                " fatal error: invalid value for cpu-arch " +
                "option must be '32' or '64'.\n");
        result 1;
    }
}
</code></pre><p>When the user passes <code>--cpu-arch=32</code> or <code>--cpu-arch=64</code> will be added <code>-m32</code> or <code>-m64</code> to the compilation command. Later, this command will be directly<br>passed to the compiler:</p><pre><code data-origin="<pre><code>$cflags = $cflags + &quot; -m&quot; + $chosen_arch;
</code></pre>">$cflags = $cflags + " -m" + $chosen_arch;
</code></pre><p>The <code>-m</code> option specifies for <em>GCC</em> the target’s architecture. Still about the last code showed, if a architecture different of <code>32</code> and <code>64</code> is passed<br>it results in a process abortion, returning 1 besides a error message on the <code>stdout</code>.</p><p>Now the function that actually compiles each scanned code takes the control:</p><pre><code data-origin="<pre><code>#  compiling...
hefesto.sys.echo(&quot;*** compiling...\n&quot;);

$exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
</code></pre>">#  compiling...
hefesto.sys.echo("*** compiling...\n");

$exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
</code></pre><p>The function <code>gcc_compile_source_list()</code> will be further detailed.</p><p>Into this toolset code exists a global variable called <code>gcc_c_project_forge_dirty_files_nr</code>. This variable computes the total of codes effectively processed.<br>If after the compilation process none of the codes were processed, the existence of the target file is verified. Not existing, the counter variable is set to<br><code>1</code>:</p><pre><code data-origin="<pre><code>if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;amp;&amp;amp; isfile($bin_output) == 0) {
    $gcc_c_project_forge_dirty_files_nr = 1;
}
</code></pre>">if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;&amp; isfile($bin_output) == 0) {
    $gcc_c_project_forge_dirty_files_nr = 1;
}
</code></pre><p>This set will guarantee the <em>linking</em> execution. Even with any code reprocessed but without the target binary, the <em>linking</em> must happen:</p><pre><code data-origin="<pre><code>if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0 &amp;amp;&amp;amp; $exit_code == 0) {
    $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
    $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
    if ($chosen_arch.len() &amp;gt; 0) {
        $ldflags = $ldflags + &quot;-m&quot; + $chosen_arch;
    }
    $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
    #  linking...
    hefesto.sys.echo(&quot;*** now linking...\n\t*** waiting...\n&quot;);
    $exit_code = gcc_link_ofiles($objects,
                                 $libraries
                                 $ldflags,
                                 $bin_output);
}
</code></pre>">if ($gcc_c_project_forge_dirty_files_nr &gt; 0 &amp;&amp; $exit_code == 0) {
    $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
    $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
    if ($chosen_arch.len() &gt; 0) {
        $ldflags = $ldflags + "-m" + $chosen_arch;
    }
    $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
    #  linking...
    hefesto.sys.echo("*** now linking...\n\t*** waiting...\n");
    $exit_code = gcc_link_ofiles($objects,
                                 $libraries
                                 $ldflags,
                                 $bin_output);
}
</code></pre><p>Of course that besides the total of processed files the <em>linking</em> must happen only when has no errors during the compiling. The <code>$exit_code == 0</code><br>in the if-clause express it.</p><p>When the <em>linking</em> is needed:</p><ul>
<li>The <em>file paths</em> of all produced object files will be gathered into a <em>string</em>;</li><li>The same is done with the linker options passed by the user (from outside, on the project declaration);</li><li>If the architecture was specified, the option that flags it is added to the linker options;</li><li>Also unserializes the additional <em>file paths</em> where some libraries can be found (these paths also are from outside, passed by the toolset user during the project declaration);</li><li>The function which effectively runs the <em>linker</em> is called: <code>gcc_link_ofiles()</code>;</li></ul><p>After a status report based on the <em>exit code</em> is shown, in order to guide the user about what happens:</p><pre><code data-origin="<pre><code>if ($exit_code == 0) {
    hefesto.sys.echo(&quot;*** success.\n&quot;);
} else {
    hefesto.sys.echo(&quot;*** failure.\n&quot;);
}
</code></pre>">if ($exit_code == 0) {
    hefesto.sys.echo("*** success.\n");
} else {
    hefesto.sys.echo("*** failure.\n");
}
</code></pre><p>Finally, the function results its <em>exit code</em> which is rather important for informing the <code>Hefesto</code> about what happened during the forge.</p><pre><code data-origin="<pre><code>result $exit_code;
</code></pre>">result $exit_code;
</code></pre><p>Now go back to the fully forge function’s source code and try to re-read each detail into the code. It is important really to understand what is being done there before continuing.</p><h5 id="detailing-each-forge-helper"><a name="detailing-each-forge-helper" href="#detailing-each-forge-helper"></a>Detailing each forge helper</h5><p>Previously the forge function was detailed, however, this function uses a set of support functions which will be detailed here.</p><h6 id="gcc_compile_source_list()"><a name="gcc_compile_source_list()" href="#gcc_compile_source_list()"></a>gcc_compile_source_list()</h6><p>Maybe this function is the most complex forge helper. For this reason, it will be the first detailed.</p><p>In this function, you will see how to watch for file changes. This watching must be implemented by the <code>toolset</code> developer. To Maintain the sanity of this<br><code>feature</code> is up to him. </p><p>There are two execution <em>branches</em>, one branch is related with the synchronous compiling process, the another one is related with the asynchronous compiling<br>process. They could be divided into two functions but here are expressed as <em>if-branches</em>.</p><p>A the synchronous compiling can be understood as one file compiled per cycle. Opposing, a asynchronous compiling can be understood as <em>n</em> files compiled per cycle.</p><p>This is the function interface:</p><pre><code data-origin="<pre><code>function gcc_compile_source_list(sources type list,
                                 includes type string,
                                 cflags type string,
                                 obj_dir type string) : result type int
</code></pre>">function gcc_compile_source_list(sources type list,
                                 includes type string,
                                 cflags type string,
                                 obj_dir type string) : result type int
</code></pre><p>The function receives the list of sources to be compiled, a string carrying all additional includes directories, a string gathering the compiler options and<br>a string which represents the directory path specifying the place where the object files should be created. When all is gracefully processed the function<br>returns <code>0</code>, otherwise it returns a non-zero value.</p><p>The beginning of the function is what follows:</p><pre><code data-origin="<pre><code>var size type int;
var i type int;
var j type int;
var exit_code type int;
var ofile type string;
var qsize_list type list;
var run_list type list;
var qsize type int;
var not_compiled type list;
var not_compiled_tmp type list;
var compile_model type list;
var is_release type int;
var curr_src_file type string;

$size = $sources.count();

if ($size == 0) result 0;

$qsize_list = hefesto.sys.get_option(&quot;qsize&quot;);

if ($qsize_list.count() &amp;gt; 0) {
    $qsize = $qsize_list.item(0);
}
</code></pre>">var size type int;
var i type int;
var j type int;
var exit_code type int;
var ofile type string;
var qsize_list type list;
var run_list type list;
var qsize type int;
var not_compiled type list;
var not_compiled_tmp type list;
var compile_model type list;
var is_release type int;
var curr_src_file type string;

$size = $sources.count();

if ($size == 0) result 0;

$qsize_list = hefesto.sys.get_option("qsize");

if ($qsize_list.count() &gt; 0) {
    $qsize = $qsize_list.item(0);
}
</code></pre><p>If passed an empty source list it will automatically return <code>0</code>. If a non-empty source list is passed, the <em>Hefesto</em> option <code>--qsize=n</code> is read. This<br>option is an internal option recognized by <code>Hefesto</code>. This option indicates the total of process that can be concurrently ran by the <code>syscall run</code>. For<br>calling the <code>run</code> on an asynchronous way is needed to pass a list containing the the external commands.</p><p>If the option <code>--qsize</code> is passed, the discussed function will get the <code>qsize</code> value for further usage. Just after:</p><pre><code data-origin="<pre><code>$compile_model = hefesto.sys.get_option(&quot;compile-model&quot;);

$is_release = 1;

if ($compile_model.count() &amp;gt; 0) {
    if ($compile_model.item(0) != &quot;release&quot; &amp;amp;&amp;amp;
        $compile_model.item(0) != &quot;debug&quot;) {
        hefesto.sys.echo(hefesto.project.toolset() +
            &quot; internal error: unknown compile model: \&quot;&quot; +
            $compile_model.item(0) + &quot;\&quot;\n&quot;);
        result 1;
    }
    $is_release = ($compile_model.item(0) == &quot;release&quot;);
}
</code></pre>">$compile_model = hefesto.sys.get_option("compile-model");

$is_release = 1;

if ($compile_model.count() &gt; 0) {
    if ($compile_model.item(0) != "release" &amp;&amp;
        $compile_model.item(0) != "debug") {
        hefesto.sys.echo(hefesto.project.toolset() +
            " internal error: unknown compile model: \"" +
            $compile_model.item(0) + "\"\n");
        result 1;
    }
    $is_release = ($compile_model.item(0) == "release");
}
</code></pre><p>The option <code>compile-model</code> is read. The content passed into this option is verified. The content must be <code>release</code> or <code>debug</code>. The default model<br>is <code>release</code>.</p><p>Now, finally, we will actually compile something:</p><pre><code data-origin="<pre><code>$exit_code = 0;
$i = 0;

$gcc_c_project_forge_dirty_files_nr = 0;

$not_compiled = lsdup($sources);

if ($qsize &amp;lt;= 1) {
    while ($i &amp;lt; $size &amp;amp;&amp;amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) +
                        &quot;: no errors found.\n&quot;);
            } else {
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) + &quot;: errors found!\n&quot;);
            }
        } else {
            hefesto.sys.echo(&quot;\t*** &quot; + $sources.item($i) + &quot;: no changes.\n&quot;);
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
} else {
    (...)
}
</code></pre>">$exit_code = 0;
$i = 0;

$gcc_c_project_forge_dirty_files_nr = 0;

$not_compiled = lsdup($sources);

if ($qsize &lt;= 1) {
    while ($i &lt; $size &amp;&amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) +
                        ": no errors found.\n");
            } else {
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) + ": errors found!\n");
            }
        } else {
            hefesto.sys.echo("\t*** " + $sources.item($i) + ": no changes.\n");
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
} else {
    (...)
}
</code></pre><p>The <em>else</em> is related with the asynchronous stuff, by now we will abstract it. Well, we have the following initializing code:</p><pre><code data-origin="<pre><code>$exit_code = 0;
$i = 0;
$gcc_c_project_forge_dirty_files_nr = 0;
$not_compiled = lsdup($sources);
</code></pre>">$exit_code = 0;
$i = 0;
$gcc_c_project_forge_dirty_files_nr = 0;
$not_compiled = lsdup($sources);
</code></pre><p>The variable which stores the <em>exit code</em> is zeroed. The list counter is zeroed too. The flag which indicates that at least one file was processed is also zeroed.<br>After is used a function defined into the <code>lsutil.hsl</code>. This function returns a copy of a passed list.</p><p>The list <code>not_compiled</code> has a special utility. By this list the <code>Hefesto</code> will be able to know what file actually has changed since the last forge.</p><p>There are two <em>built-in</em> functions into the <code>toolset sub-system</code>:</p><ul>
<li><code>hefesto.toolset.file_has_change(&lt;file-path&gt;)</code></li><li><code>hefesto.toolset.base_refresh(&lt;untouched-files&gt;)</code></li></ul><p>The <code>file_has_change()</code> is pretty straightforward:</p><blockquote>
<p>Receives a <em>file path</em> and returns <strong>1</strong> if it has changed otherwise <strong>0</strong>.</p>
</blockquote><p>Now the <code>base_refresh()</code>:</p><blockquote>
<p>Receives a list of <strong>not processed</strong> <em>file paths</em>.</p>
</blockquote><p>The <em>workflow</em> for using these functions is basically to call <code>file_has_change()</code> in order to know if the related file has changed. If it has changed the<br>specific processing imposed by the toolset must be applied over this file. If this file was sucessfully processed its file path should be removed from the<br>list that will be passed to the <code>base_refresh()</code>. After processing all files, a single call to <code>base_refresh()</code> should be done in order to refresh the<br>files status for the next forge. Only with these two functions the <em>Hefesto</em> is able to know exactly what has changed since the last forge.</p><p>Returning to the code:</p><pre><code data-origin="<pre><code>if ($qsize &amp;lt;= 1) {
    while ($i &amp;lt; $size &amp;amp;&amp;amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) +
                        &quot;: no errors found.\n&quot;);
            } else {
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) + &quot;: errors found!\n&quot;);
            }
        } else {
            hefesto.sys.echo(&quot;\t*** &quot; + $sources.item($i) + &quot;: no changes.\n&quot;);
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
}
</code></pre>">if ($qsize &lt;= 1) {
    while ($i &lt; $size &amp;&amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) +
                        ": no errors found.\n");
            } else {
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) + ": errors found!\n");
            }
        } else {
            hefesto.sys.echo("\t*** " + $sources.item($i) + ": no changes.\n");
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
}
</code></pre><p>If the requested forge is synchronous, <code>--qsize=1</code> (by the way, the default), for each file path (<em>C</em> code) into the list, not occuring compiling errors:</p><blockquote>
<p>Based on the file path, we use the function <code>gcc_mk_ofile_name()</code> to create an object file name, in fact just replacing the <code>.c</code> extension by <code>.o</code> joining these new name with the objects directory string.</p>
<p>We verify if the file <code>.c</code> has some change or if its related object file not exist.</p>
<blockquote>
<p>With this condition satisfied, we increment the file processing counter and also we run the compiling command. If the file was successfully processed its path is removed from the list <code>not_compiled</code>.</p>
<p>If the file <code>.c</code> has not changed and its object file exists, we inform that has no changes for it. </p>
</blockquote>
</blockquote><p>After processing all source code files, if at least one file was processed, the <code>base_refresh()</code> is called and finally the <em>exit code</em> is returned to the<br>caller which must take some action based on the returned value.</p><p>Now let’s see the asynchronous part of this forge helper:</p><pre><code data-origin="<pre><code>else {
    $not_compiled_tmp.clear();
    while ($i &amp;lt; $size) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $run_list.add_item(
                gcc_mk_app_compilation_command($curr_src_file,
                                               $ofile,
                                               $includes,
                                               $cflags,
                                               $is_release));
            $not_compiled_tmp.add_item($sources.item($i));
        }
        if ($run_list.count() == $qsize) {
            $exit_code = hefesto.sys.run($run_list);
            if ($exit_code == 0) {
                $j = 0;
                while ($j &amp;lt; $not_compiled_tmp.count()) {
                    $not_compiled.del_item($not_compiled_tmp.item($j));
                    $j = $j + 1;
                }
                $not_compiled_tmp.clear();
                hefesto.toolset.base_refresh($not_compiled);
            }
            $run_list.clear();
        }
        $i = $i + 1;
    }
    if($run_list.count() &amp;gt; 0) {
        $exit_code = hefesto.sys.run($run_list);
        if ($exit_code == 0) {
            $j = 0;
            while ($j &amp;lt; $not_compiled_tmp.count()) {
                $not_compiled.del_item($not_compiled_tmp.item($j));
                $j = $j + 1;
            }
            hefesto.toolset.base_refresh($not_compiled);
        }
    }
}
</code></pre>">else {
    $not_compiled_tmp.clear();
    while ($i &lt; $size) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $run_list.add_item(
                gcc_mk_app_compilation_command($curr_src_file,
                                               $ofile,
                                               $includes,
                                               $cflags,
                                               $is_release));
            $not_compiled_tmp.add_item($sources.item($i));
        }
        if ($run_list.count() == $qsize) {
            $exit_code = hefesto.sys.run($run_list);
            if ($exit_code == 0) {
                $j = 0;
                while ($j &lt; $not_compiled_tmp.count()) {
                    $not_compiled.del_item($not_compiled_tmp.item($j));
                    $j = $j + 1;
                }
                $not_compiled_tmp.clear();
                hefesto.toolset.base_refresh($not_compiled);
            }
            $run_list.clear();
        }
        $i = $i + 1;
    }
    if($run_list.count() &gt; 0) {
        $exit_code = hefesto.sys.run($run_list);
        if ($exit_code == 0) {
            $j = 0;
            while ($j &lt; $not_compiled_tmp.count()) {
                $not_compiled.del_item($not_compiled_tmp.item($j));
                $j = $j + 1;
            }
            hefesto.toolset.base_refresh($not_compiled);
        }
    }
}
</code></pre><p>The behavior is similar of the synchronous stuff. The difference is that the compiling commands are not directly executed, being they added to a list for<br>executing at the end of the cycle. Another difference here is the usage of the temporary list <code>not_compiled_tmp</code> which are filled per cycles. Also the<br><code>base-refresh</code> is done per cycle. A cycle is considered done when the size of <code>run_list</code> is equals to the value of the <code>--qsize</code>. If the compiling<br>of any file return a error the process is totally interrupted. Otherwise it will continue until get all source code files processed.</p><h6 id="gcc_mk_app_compilation_command()"><a name="gcc_mk_app_compilation_command()" href="#gcc_mk_app_compilation_command()"></a>gcc_mk_app_compilation_command()</h6><p>This function makes the commands that will be executed using the previous toolset commands:</p><pre><code data-origin="<pre><code>local function gcc_mk_app_compilation_command(src_name type string,
                                              outfile type string,
                                              includes type string,
                                              cflags type string,
                        is_release type int) : result type string {
    var cmd type string;
    if ($is_release == 1) {
        $cmd = hefesto.toolset.compile_r($src_name, $outfile, $includes, $cflags);
    } else {
        $cmd = hefesto.toolset.compile_d($src_name, $outfile, $includes, $cflags);
    }
    result $cmd;
}
</code></pre>">local function gcc_mk_app_compilation_command(src_name type string,
                                              outfile type string,
                                              includes type string,
                                              cflags type string,
                        is_release type int) : result type string {
    var cmd type string;
    if ($is_release == 1) {
        $cmd = hefesto.toolset.compile_r($src_name, $outfile, $includes, $cflags);
    } else {
        $cmd = hefesto.toolset.compile_d($src_name, $outfile, $includes, $cflags);
    }
    result $cmd;
}
</code></pre><p>If you have understood the concepts related with the <code>toolset commands</code>, I think that this function is quite straighforward.</p><h6 id="gcc_link_ofiles()"><a name="gcc_link_ofiles()" href="#gcc_link_ofiles()"></a>gcc_link_ofiles()</h6><p>This function is responsible for <em>linking</em> the produced object files building the application using the name specified into <code>appname</code>.</p><p>The objects list is expressed as a string, in form that <em>GCC</em> expects, e.g.: <em>“foo.o bar.o baz.o”</em>.</p><p>The variables <code>libraries</code> and <code>ldflags</code> the same thing. They are in form that <em>GCC</em> expects.</p><p>The first thing that this function does is to check if the option <code>--link-model</code> was passed by the user. This option allows two models <code>static</code> or <code>shared</code> (the default).<br>If the user has passed an alien model the process will break with a error.</p><p>The <code>link-model</code> decides which toolset command related with linking should be picked. This command is made by the toolset and executed with the <code>syscall run</code>.<br>The <em>exit code</em> of the <em>linking</em> is captured and returned to the caller which will take some action based on it.</p><p>Take a look at the code listing reviewing about what you have read:</p><pre><code data-origin="<pre><code>function gcc_link_ofiles(objects type string,
                         libraries type string,
                         ldflags type string,
                         appname type string) : result type int {
    var exit_code type int;
    var link_model type list;
    var is_static type int;
    $link_model = hefesto.sys.get_option(&quot;link-model&quot;);
    $is_static = 0;
    if ($link_model.count() &amp;gt; 0) {
        if ($link_model.item(0) == &quot;static&quot;) {
            $is_static = 1;
        } else {
            if ($link_model.item(0) != &quot;shared&quot;) {
                hefesto.sys.echo(hefesto.project.toolset() +
                        &quot; internal error: unknown link model: \&quot;&quot; +
                        $link_model.item(0) + &quot;\&quot;\n&quot;);
                result 1;
            }
        }
    }
    if ($is_static == 1) {
        $exit_code = hefesto.sys.run(
            hefesto.toolset.link_static($appname,
                                        $objects,
                                        $libraries, $ldflags));
    } else {
        $exit_code = hefesto.sys.run(
           hefesto.toolset.link_shared($appname,
                                    $objects,
                                    $libraries, $ldflags));
    }
    result $exit_code;
}
</code></pre>">function gcc_link_ofiles(objects type string,
                         libraries type string,
                         ldflags type string,
                         appname type string) : result type int {
    var exit_code type int;
    var link_model type list;
    var is_static type int;
    $link_model = hefesto.sys.get_option("link-model");
    $is_static = 0;
    if ($link_model.count() &gt; 0) {
        if ($link_model.item(0) == "static") {
            $is_static = 1;
        } else {
            if ($link_model.item(0) != "shared") {
                hefesto.sys.echo(hefesto.project.toolset() +
                        " internal error: unknown link model: \"" +
                        $link_model.item(0) + "\"\n");
                result 1;
            }
        }
    }
    if ($is_static == 1) {
        $exit_code = hefesto.sys.run(
            hefesto.toolset.link_static($appname,
                                        $objects,
                                        $libraries, $ldflags));
    } else {
        $exit_code = hefesto.sys.run(
           hefesto.toolset.link_shared($appname,
                                    $objects,
                                    $libraries, $ldflags));
    }
    result $exit_code;
}
</code></pre><p>Well, all done. A good exercise is try to create a <code>toolset</code> for automating something based on your own necessities. It is not necessary be related with<br>compilers. For example, you can try to create a <code>toolset</code> which does the <em>deploy</em> of your package, etc. Be creative!</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
