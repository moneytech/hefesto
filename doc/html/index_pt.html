<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Untitled.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="um-*build-system*-chamado-hefesto"><a name="um-*build-system*-chamado-hefesto" href="#um-*build-system*-chamado-hefesto"></a>Um <em>build system</em> chamado Hefesto</h1><p><em>por Rafael Santiago</em></p><hr class="section"><p><strong>Resumo</strong>: Nesse documento você encontra algumas informações relacionadas ao projeto. Minhas motivações. Detalhes gerais sobre a <code>HSL</code>. Decisões de projeto. Loucas divagações e ideias que podem ferir as suas, se você for uma alma sensível… :-)</p><hr class="section"><h2 id="hefesto-quem?!"><a name="hefesto-quem?!" href="#hefesto-quem?!"></a>Hefesto quem?!</h2><p><code>Hefesto</code> é um <em>build system</em> nada ortodoxo propício para gente conservadora odiar… O principal conceito dele é evidenciar tudo o que está sendo feito em termos de <em>build</em> no seu projeto de <em>software</em> lhe oferecendo as ferramentas básicas para isso.</p><h2 id="a-motivação"><a name="a-motivação" href="#a-motivação"></a>A motivação</h2><p><em>Hefesto</em> é um <em>build system</em> que resolvi criar buscando responder algumas perguntas que sempre fiz em termos de <em>build systems</em>:</p><ul>
<li>Por que <em>build systems</em> adotam linguagens excessivamente declarativas?</li><li>Por que a sintaxe dessas linguagens em geral são horrendas?</li><li>Por que o desenvolvedor não pode se sentir programando o <em>build</em>?</li><li>Por que para que ele se sinta assim precisa empilhar tanta coisa junto?</li><li>É feio, nada polido, prezar por…. concisão, completude e clareza?!</li><li>Por que adotar a filosofia do caracol para se sentir em casa?</li></ul><p>Talvez à medida que começar descrever o que criei você note que o <em>Hefesto</em> não é necessariamente um <em>build system</em> mas sobre o que um <em>build system</em> na essência é.</p><h3 id="automate-or-die!"><a name="automate-or-die!" href="#automate-or-die!"></a>Automate or die!</h3><p>Eu desenvolvo <em>software</em> e gosto de automatizar coisas, qualquer tipo de tarefa repetitiva é uma tortura para mim, pois eu poderia estar fazendo outra coisa no lugar da repetição.</p><p>Atualizando minha última afirmação: eu desenvolvo <em>software</em> e gosto de pensar em coisas novas o tempo todo e por isso <em>preciso</em> automatizar.</p><p>Ao meu ver a automatização mais básica no ciclo que envolve o desenvolvimento de um <em>software</em> remonta aos primórdios de seu surgimento, em outras palavras, remonta ao seu <em>build</em>.</p><p>Temos incontáveis formas de automatizar <em>builds</em> desde <em>shell scripts</em> e <em>batch files</em> arcanas, até os <em>Makefiles</em>, <em>Jamfiles</em> e etc.</p><p>Ao longo das décadas que venho programando já usei todos os que citei e mais alguns. Pessoalmente, nunca fui atendido por completo por nenhum deles e às vezes me irritaram muito.</p><p>Vou itemizar uns aspectos gerais que me fizeram desistir deles e <ins>apenas (à penas mesmo) usá-los</ins> quando o “senso” comum me obriga:</p><ul>
<li>Linguagens simbólicas;</li><li>Linguagens <a href="http://pt.wikipedia.org/wiki/Whitespace">Whitespace-Like</a>;</li><li>O poder de fogo não é constante quando mudamos de plataforma;</li><li>Às vezes é preciso instalar uma infinidade de coisas para manter o poder de fogo, sem necessidade, se o <em>build system</em> tivesse sido bem pensado;</li><li>Documentação confusa e nada direta;</li><li>Mistureba de Linguagens sem nenhuma necessidade;</li><li>Utilização confusa, envolvendo duas ou mais ferramentas para cumprir todo o ciclo do processo;</li><li>Ferramentas visuais baseadas em <em>XML</em> que é por sua vez horrível de versionar e tirar <em>diffs</em>, a coisa se torna ainda pior quando o <em>XML</em> é gerado automaticamente;</li><li>Adaptar seu senso de qualidade e clareza nivelando por baixo, algo como, preciso pensar meu círculo assim pois meu <em>build system</em> me oferece uma lacuna no formato de um triângulo… “Sim, veja! É incrível como meu círculo se encaixa nesse triângulo menor que ele!!! Por essa eu não esperava….”</li></ul><h2 id="como-funciona-o-*hefesto*"><a name="como-funciona-o-*hefesto*" href="#como-funciona-o-*hefesto*"></a>Como funciona o <em>Hefesto</em></h2><p>O <em>Hefesto</em> leva em consideração que você é um programador que <ins>conhece</ins> os compiladores que está usando. Se você se julga um <em>sniper</em> mas até hoje se limitou em usar armas de <em>paintball</em> pare de ler isso.</p><p>Ele é baseado no conceito de automatizar a essência do processo de <em>build</em> de um <em>software</em> e isso recai na compilação e <em>linkedição</em>, na maioria das vezes. Sou programador <em>C</em> e o <em>Hefesto</em> é em grande parte feito nela, quando não, é feito na Linguagem que ele implementa, que por sinal vou apresentar depois de mostrar a cara de um <em>script</em> de <em>build</em> <em>Hefesto</em>.</p><p>Quase todo <em>build system</em> possui um arquivo mágico que se existe no diretório <em>sheebang!</em> No <em>Hefesto</em> não… ele deixa você dar o nome que melhor se adequa ao<br>seu estado de coisas. Eu gosto de chamar os meus de <code>Forgefiles</code>.</p><p>Segue um exemplo de um <code>Forgefile</code> para uma <em>lib</em> escrita em <em>C</em>:</p><pre><code data-origin="<pre><code>    # Comment-sample: Forgefile.hsl...

    include ~/toolsets/gcc/gcc-lib.hsl

    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset &quot;gcc-c-lib&quot; : $sources, $includes, $cflags, $libraries, $ldflags, &quot;libhere.a&quot;;

    here.prologue() {
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    # Comment-sample: Forgefile.hsl...

    include ~/toolsets/gcc/gcc-lib.hsl

    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset "gcc-c-lib" : $sources, $includes, $cflags, $libraries, $ldflags, "libhere.a";

    here.prologue() {
        $sources.ls(".*\\.c$");
    }
</code></pre><p>A <code>HSL</code> já começa aqui e continua dentro do <code>toolset</code>. <code>HSL</code> pode ser entendida como <code>H</code>efesto <code>S</code>cripting <code>L</code>anguage. É a Linguagem que se usa tanto para criar <em>builds</em> ou para automatizar a essência deles. O conjunto de automatizações do <code>essencial de um build</code> pode ser entendido como um <code>toolset</code>.</p><p>Note que no <code>Forgefile</code> apresentado, após o comentário, é feita uma inclusão bem sugestiva. Estamos incutindo nesse <code>Forgefile</code> uma base de conhecimento prévia que recai sobre como executar um <em>build</em> de uma biblioteca escrita em <em>C</em> usando o compilador <em>GCC</em>.</p><p>Depois disso, algo que muitos odeiam com paixão. Você precisa declarar tudo, absolutamente tudo o que vai usar. Algo como: “ei pessoal, preciso usar isso aqui então, com licença viu?”.</p><p>Do ponto de vista do <em>design de Linguagens de programação</em>, eu pessoalmente acho que a necessidade de declaração de uma variável é uma <em>feature</em> que salta do dispositivo direto para a consciência do usuário, pois no momento da declaração ele será levado a pensar sobre o porquê e se realmente precisa daquela variável naquele dado momento.<br>Salvo isso, continuemos…</p><p>Essas variáveis declaradas são utilizadas pela <code>função de forja</code> (entenda por enquanto como o ponto de entrada para a parte mais interna do <em>build</em>).</p><p>Após a declaração das variáveis, <code>declaramos o projeto</code>. Dizendo algo na linha: </p><blockquote>
<p>“Esse projeto se chama “here” é uma <em>lib</em> escrita em <em>C</em> que esperamos compilar com o <em>GCC</em>. Seguem os parâmetros na ordem que o motor de <em>build</em> para esse tipo de coisa espera.”</p>
</blockquote><p>Esse <code>toolset</code> espera receber uma lista de <code>códigos</code> para compilar, uma lista de diretórios de <code>includes</code> usados durante a compilação, uma lista de <code>opções de compilação</code> que o compilador em questão entende, uma lista de diretórios onde ficam as <code>libs</code>, uma lista de <code>flags</code> de compilação e um <code>nome para o arquivo</code> que será produzido pelo processo, em outras palavras a <em>lib</em> propriamente dita.</p><p>Um problema com a maioria dos <em>build systems</em> é quanto a definição dos códigos a serem processados. Alguns deixam a coisa solta e podemos ler essa lista de qualquer lugar, outros não disponibilizam mecanismos para isso.</p><p>O <em>Hefesto</em> fica no meio termo, antes de um <em>build</em> começar, às vezes, para não dizer quase sempre… existem uma infinidade de coisas muito específicas àquele projeto que precisam ser feitas. Quando um projeto é criado no <em>Hefesto</em>, juntamente com ele são criados três pontos de entrada: <code>preloading</code>, <code>prologue</code> e <code>epilogue</code>.</p><p>Confira na <strong>Tabela 1</strong> em que momento do processo esses pontos de entrada são atingidos. A ideia básica aqui é: se existe código definido dentro deles, no momento esperado, esses códigos serão executados.</p><p><strong>Tabela 1</strong>: Os estágios de um projeto <em>Hefesto</em>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Project entry-point</strong></th>
<th style="text-align:center"><strong>Executado</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>preloading</code></td>
<td style="text-align:center">Antes mesmo de carregar o toolset</td>
</tr>
<tr>
<td style="text-align:center"><code>prologue</code></td>
<td style="text-align:center">Antes da forja ser iniciada</td>
</tr>
<tr>
<td style="text-align:center"><code>epilogue</code></td>
<td style="text-align:center">Após a forja ser finalizada</td>
</tr>
</tbody>
</table><p>Esqueçamos por hora o <code>preloading</code> e o <code>epilogue</code>. Há uma coisa muito básica que sempre deverá ser feita antes de começar uma forja que é coletar os <em>file paths</em> dos códigos que precisam ser processados. Então, no <code>prologue</code> do exemplo:</p><pre><code data-origin="<pre><code>    here.prologue() {
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    here.prologue() {
        $sources.ls(".*\\.c$");
    }
</code></pre><p>Não se preocupe com o <code>.ls()</code>… Nas seções futuras quando descrever melhor a <code>HSL</code> os facilitadores de lista serão apresentados e tudo talvez faça mais sentido.</p><p>Com o <code>Forgefile</code> escrito, a forja poderia ser invocada na linha de comando da seguinte forma:</p><blockquote>
<p><code>hefesto --forgefiles=Forgefile.hsl --Forgefile-projects=here</code></p>
</blockquote><p>Note que na opção <code>--forgefiles</code> é especificada uma lista de arquivos contendo projetos. A outra opção é dinâmica e baseada nos arquivos passados em <code>--forgefiles</code>. O esquema geral dessa opção dinâmica é:</p><blockquote>
<p><code>--&lt;file-name&gt;-projects=&lt;projects defined inside this file&gt;</code></p>
</blockquote><p>Já sei:</p><blockquote>
<p>ZzZZzzzZzzzZzZZZZZZzzzzzzZzzzZzzzzzZZZZZZZzzzzZZZ que comando longo… não posso digitar algo mais breve? </p>
</blockquote><p>Pode sim, você precisa criar um arquivo de invocação e imolar 5 cabras em nome de <em>Hefesto</em>… O arquivo de invocação precisa estar no diretório onde você deseja invocar a forja, o nome desse arquivo é <code>.ivk</code> e dentro dele você deve colocar a linha de comando exatamente como passaria para o <em>Hefesto</em>.</p><p>Com o <code>.ivk</code> configurado, estando no diretório dele, apenas digitando <code>hefesto</code> você terá a forja nos moldes padrão que você necessita e definiu. Caso passe opções nessa chamada, as opções que você fornecer terão precedência maior quando <em>mergeadas</em> com as opções do arquivo de invocação.</p><p>E quanto as cabras?! Não precisa, era só brincadeira…</p><p>Pronto, agora você já sabe os passos básicos para compor um <code>Forgefile</code> no <em>Hefesto</em>, mas o que você não sabe ainda são os detalhes gerais da <code>HSL</code> e de como criar mais <code>toolsets</code> que atendam suas necessidades.</p><p>Os <code>toolsets</code> por sua vez são porções de código <code>HSL</code> que podem ter suas próprias convenções, conveniências, etc. Por isso, antes de usá-los uma boa providência é consultar a documentação específica desse <code>toolset</code>. Se você o baixou da base oficial provavelmente encontrará algum texto que o detalhe.</p><h3 id="reprocessando-somente-o-que-mudou-desde-a-última-forja,-tem-como?"><a name="reprocessando-somente-o-que-mudou-desde-a-última-forja,-tem-como?" href="#reprocessando-somente-o-que-mudou-desde-a-última-forja,-tem-como?"></a>Reprocessando somente o que mudou desde a última forja, tem como?</h3><p>Sim, isso envolve requisitar essa necessidade na declaração do projeto. Vamos usar o mesmo projeto de <em>lib</em> do exemplo anterior.</p><p>Anteriormente a declaração era essa:</p><pre><code data-origin="<pre><code>    project here : toolset &quot;gcc-c-lib&quot; : $sources, $includes, $cflags, $libraries, $ldflags, &quot;libhere.a&quot;;
</code></pre>">    project here : toolset "gcc-c-lib" : $sources, $includes, $cflags, $libraries, $ldflags, "libhere.a";
</code></pre><p>Agora vamos incluir a especificação da cadeia de dependências ou <code>dep-chain</code>. Uma <code>dep-chain</code> basicamente é uma <code>string</code> expressa num formato especial:</p><blockquote>
<p><code>&lt;file-path&gt;</code> <strong>:</strong>  <code>&lt;file-path_0&gt;</code> [ <strong>&amp;</strong> <code>&lt;file-path_n&gt;</code> ] <strong>;</strong></p>
</blockquote><p>Imagine que <code>a.x</code> depende de <code>b.x</code> que depende de <code>c.x</code> que por sua vez depende de <code>d.x</code> e <code>e.x</code>. A <code>dep-chain</code> para essa situação seria:</p><blockquote>
<p>a.x: b.x;</p>
<p>b.x: c.x;</p>
<p>c.x: d.x &amp; e.x;</p>
</blockquote><p>No caso de programas reais isso pode ser bem maçante de se escrever, a biblioteca padrão do <code>Hefesto</code> inclui funções em <code>HSL</code> que tentam inferir por meios heurísticos a interdependência entre os arquivos que compõem um projeto.</p><p>Segue um uso prático das <code>dep-chains</code>:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset &quot;gcc-c-lib&quot; : dependencies $deps : $sources,
                                                              $includes,
                                                              $cflags,
                                                              $libraries,
                                                              $ldflags,
                                                              &quot;libhere.a&quot; ;

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;

    project here : toolset "gcc-c-lib" : dependencies $deps : $sources,
                                                              $includes,
                                                              $cflags,
                                                              $libraries,
                                                              $ldflags,
                                                              "libhere.a" ;

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(".*\\.c$");
    }
</code></pre><p>Note que agora foi inclusa a diretiva <code>dependencies &lt;string&gt;</code> na declaração do projeto, além do uso da função <code>get_c_cpp_deps()</code> importada de <code>dependency_scanner.hsl</code>. Contudo, você mesmo poderia grafar a sua <code>string</code> de dependência, caso quisesse. Importante ressaltar que uma <code>dep-chain</code> mal formada é silenciosamente descartada pelo aplicativo. Esteja sempre atento durante a composição delas.</p><p>E Pronto! Apenas com isso seus arquivos começarão serem processados somente quando houverem alterações explícitas neles ou em algum outro arquivo que eles dependam.</p><h4 id="como-forçar-o-reprocessamento-de-tudo?"><a name="como-forçar-o-reprocessamento-de-tudo?" href="#como-forçar-o-reprocessamento-de-tudo?"></a>Como forçar o reprocessamento de tudo?</h4><p>Use a opção <code>--forge-anyway</code> ao invocar uma forja.</p><h4 id="algo-mais-que-deva-saber-sobre-as-*dep-chains*?"><a name="algo-mais-que-deva-saber-sobre-as-*dep-chains*?" href="#algo-mais-que-deva-saber-sobre-as-*dep-chains*?"></a>Algo mais que deva saber sobre as <em>dep-chains</em>?</h4><p>Sim, quando você adota o uso de <code>dep-chains</code> em um projeto os seus argumentos durante a invocação da forja começam ser monitorados. A decisão de projeto que adotei foi:</p><blockquote>
<p>Se existe um <code>bit</code> que seja de diferença entre os argumentos de forja atuais e os últimos de uma forja bem sucedida, <strong>tudo será reprocessado</strong>. Ao meu ver o preço que se paga é menor. Se não há como saber que <code>flag</code> é passível de reprocessamento de um mar de <code>flags</code> é mais confiável sempre reprocessar e acabou. A praticidade cotidiana não é uma <em>top-model</em> mas na sua simplicidade traz seus encantos…</p>
<p>Sinceramente eu não acho que programadores realmente ocupados e com objetivos reais e bem conscientes ficam macaqueando <code>flags</code> aleatórias o tempo todo para um <code>build</code> ou disputando <code>build-turfe</code> por aí. Você conhece algum?!</p>
</blockquote><p>Uma alteração de arquivo é julgada <strong>não pela data de alteração</strong>, mas <strong>com base no conteúdo</strong>. Com um <code>bit</code> de diferença um arquivo já será considerado “sujo”.</p><h3 id="yoda`s-proposal:-que-tal-em-*runtime*-o-*toolset*-mudar?"><a name="yoda`s-proposal:-que-tal-em-*runtime*-o-*toolset*-mudar?" href="#yoda`s-proposal:-que-tal-em-*runtime*-o-*toolset*-mudar?"></a>Yoda`s proposal: que tal em <em>runtime</em> o <em>toolset</em> mudar?</h3><p>Sim meu jovem <em>Luke</em>, não tenha medo muito… isso é possível. Para isso só é preciso ter uma precaução <em>Jedi</em>: os <em>toolsets</em> a serem escolhidos devem possuir a mesma assinatura de função para a função de forja, em outras palavras, devem receber o mesmo número de argumentos, na mesma ordem e tipo.</p><p>Lembra quando foram apresentados os <code>entry-points</code> de um projeto de forja? Que o <code>entry-point</code> chamado <code>preloading</code> ocorre mesmo antes do <code>toolset</code> ao qual o projeto é dependente ser carregado? Vamos usar esse <code>big-bang</code> para criar um <em>Forgefile</em> mais adaptável ao ambiente.</p><p>Vamos pegar o projeto daquela <em>lib</em> apresentado e criar o seguinte requisito:</p><blockquote>
<p>Se estivermos no <code>Windows</code> daremos preferência por usar o <em>Visual Studio 2012</em>, caso ele exista na máquina. Não existindo usaremos o <em>GCC</em>, nas demais plataformas usaremos sempre o <em>GCC</em>.</p>
</blockquote><p>Vou apresentar o <em>Forgefile</em> alterado e comentar as partes interessantes depois.</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;
    var current_toolset type string;

    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   &quot;libhere.a&quot; ;

    function has_vs_110() : result type int {
        var winreg_rkey type list;
        $winreg_rkey.add_item(&quot;HKLM&quot;);
        $winreg_rkey.add_item(&quot;HKCU&quot;);

        var subkeys type list;
        $subkeys.add_item(&quot;\\SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0&quot;);
        $subkeys.add_item(&quot;\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0&quot;);

        var s type int;
        var subkey type string;
        var w type int;
        var root_key type string;
        var install_dir type string;

        $s = 0;
        while ($s &amp;lt; $subkeys.count()) {
            $subkey = $subkeys.item($s);
            $w = 0;
            while ($w &amp;lt; $winreg_rkey.count()) {
                $root_key = $winreg_rkey.item($w);
                $install_dir = hefesto.sys.env(&quot;WINREG:&quot; +
                                               $root_key +
                                               $subkey);
                if ($install_dir.len() &amp;gt; 0) result 1;
                $w = $w + 1;
            }
            $s = $s + 1;
       }
       result 0;
    }

    here.preloading() {
        $current_toolset = &quot;gcc-c-lib&quot;;
        if (hefesto.sys.os_name() == &quot;windows&quot;) {
            if (has_vs_110()) {
                $current_toolset = &quot;vc110-lib&quot;;
            }
        }
    }

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(&quot;.*\\.c@@bodyquot;);
    }
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
    include ~/toolsets/common/utils/lang/c/dependency_scanner.hsl

    var deps type string;
    var sources type list;
    var includes type list;
    var cflags type list;
    var libraries type list;
    var ldflags type list;
    var current_toolset type string;

    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   "libhere.a" ;

    function has_vs_110() : result type int {
        var winreg_rkey type list;
        $winreg_rkey.add_item("HKLM");
        $winreg_rkey.add_item("HKCU");

        var subkeys type list;
        $subkeys.add_item("\\SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0");
        $subkeys.add_item("\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\SxS\\VS7\\11.0");

        var s type int;
        var subkey type string;
        var w type int;
        var root_key type string;
        var install_dir type string;

        $s = 0;
        while ($s &lt; $subkeys.count()) {
            $subkey = $subkeys.item($s);
            $w = 0;
            while ($w &lt; $winreg_rkey.count()) {
                $root_key = $winreg_rkey.item($w);
                $install_dir = hefesto.sys.env("WINREG:" +
                                               $root_key +
                                               $subkey);
                if ($install_dir.len() &gt; 0) result 1;
                $w = $w + 1;
            }
            $s = $s + 1;
       }
       result 0;
    }

    here.preloading() {
        $current_toolset = "gcc-c-lib";
        if (hefesto.sys.os_name() == "windows") {
            if (has_vs_110()) {
                $current_toolset = "vc110-lib";
            }
        }
    }

    here.prologue() {
        $deps = get_c_cpp_deps();
        $sources.ls(".*\\.c$");
    }
</code></pre><p>A função <code>has_vs_110</code> verifica no registro do sistema a entrada de chave existente caso haja o <em>Visual Studio</em> na máquina, leia a seção <code>Sobre a HSL</code> que você entenderá a lógica básica e o uso de <code>hefesto syscalls</code> nessa função. Se existir na máquina retornará 1, de outra forma 0.</p><p>Note que no <code>preloading</code> do projeto apenas chamaremos essa função se estivermos executando a forja sob o <code>Windows</code> (novamente, consulte a seção <code>Sobre a HSL</code>) e se existir o <em>Visual Studio</em> na máquina, setamos o nome do toolset para “vc110-lib”. Caso contrário, o <code>toolset</code> será o padrão “gcc-c-lib”. Pelo fato da declaração possuir uma indireção para o nome do <code>toolset</code> via a variável que setamos no <code>preloading</code>:</p><pre><code data-origin="<pre><code>    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   &quot;libhere.a&quot; ;
</code></pre>">    project here : toolset $current_toolset : dependencies $deps : $sources,
                                                                   $includes,
                                                                   $cflags,
                                                                   $libraries,
                                                                   $ldflags,
                                                                   "libhere.a" ;
</code></pre><p>Passamos ter a seleção do <code>toolset</code> em <code>runtime</code>, pois quando o <code>toolset</code> estiver sendo carregado o <code>Hefesto</code> já vai ter passado pelo <code>preloading</code> do nosso projeto. Por esse motivo é importante ter a mesma assinatura de forja entre os <code>toolsets</code>, pois só podemos declarar um projeto uma vez. Mas isso vai da inteligência e mais do que isso, do senso de reutilização do desenvolvedor dos <code>toolsets</code> que você for usar.</p><p>Mas ainda tem um “problema” nisso aí… observe no início do exemplo:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include ~/toolsets/vc/vc110-lib.hsl
</code></pre><p>Nossa forja é multiplataforma, mas não precisamos incluir o módulo <code>vc110-lib.hsl</code> fora do <code>Windows</code>, não usaremos <em>Visual Studio</em> no <code>Linux</code>, para que ocupar o <code>Hefesto</code> em processar esse módulo sem necessidade toda vez? Que tal melhorar para:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-lib.hsl
    include on windows ~/toolsets/vc/vc110-lib.hsl
</code></pre>">    include ~/toolsets/gcc/gcc-lib.hsl
    include on windows ~/toolsets/vc/vc110-lib.hsl
</code></pre><p>Pronto!</p><p>A diretiva <code>include</code> aceita uma lista de plataformas para efetivamente incluir um arquivo <code>HSL</code> dentro de outro, se houvesse necessidade de incluir um arquivo apenas no <code>FreeBSD</code> e no <code>Linux</code>:</p><pre><code data-origin="<pre><code>    include on freebsd,linux posix/utils.hsl
</code></pre>">    include on freebsd,linux posix/utils.hsl
</code></pre><h3 id="como-rodo-meus-testes?"><a name="como-rodo-meus-testes?" href="#como-rodo-meus-testes?"></a>Como rodo meus testes?</h3><p>Nada me irrita mais do que a necessidade de criar <code>batch-files</code> ou mesmo <code>shell-scripts</code> para rodar testes e outras tarefas pré e pós compilação. Organização ao meu ver envolve uniformidade e quanto menos mistureba melhor e o paraíso seria perfeito se pudessemos deixar tudo dentro da mesma esfera.</p><p>Que tal usar o <code>entry-point epilogue</code> para disparar a compilação e execução dos testes, avaliando se quebraram ou passaram? No exemplo, da nossa <em>lib</em>, adicionaríamos:</p><pre><code data-origin="<pre><code>    here.epilogue() {
        var notest type list;
        if (hefesto.sys.last_forge_result() == 0) {
            $notest = hefesto.sys.get_option(&quot;no-test&quot;);
            if ($notest.count() == 0) {
                run_tests();
            }
        }
    }

    function run_tests() : result type none {
        var retval type int;
        hefesto.sys.cd(&quot;test&quot;);
        $retval = hefesto.sys.forge(&quot;here-test&quot;, &quot;Forgefile.hsl&quot;, &quot;--bin-output-dir=bin --obj-output-dir=obj&quot;);
        hefesto.sys.cd(&quot;..&quot;);
    }
</code></pre>">    here.epilogue() {
        var notest type list;
        if (hefesto.sys.last_forge_result() == 0) {
            $notest = hefesto.sys.get_option("no-test");
            if ($notest.count() == 0) {
                run_tests();
            }
        }
    }

    function run_tests() : result type none {
        var retval type int;
        hefesto.sys.cd("test");
        $retval = hefesto.sys.forge("here-test", "Forgefile.hsl", "--bin-output-dir=bin --obj-output-dir=obj");
        hefesto.sys.cd("..");
    }
</code></pre><p>Desculpe se estou adiantando um pouco as coisas aqui, mas basicamente em <code>epilogue</code> verifico se o <code>build</code> atual de nossa <em>lib</em> foi realmente bem sucedido, se tiver sido, vejo se a opção de usuário <code>--no-test</code> foi passada, caso não tenha sido, chamo a função de execução dos testes.</p><p>A função <code>run-tests</code> por sua vez muda para o subdiretório <code>test</code> onde teremos um outro projeto de forja o qual disparamos. Após isso, finalizamos voltando ao diretório anterior.</p><p>Agora vamos ver como é esse <em>Forgefile</em> dos testes:</p><pre><code data-origin="<pre><code>    include ~/toolsets/gcc/gcc-app.hsl

    var sources type list;
    var includes type list;
    var libraries type list;
    var ldflags type list;
    var cflags type list;

    project here-test : toolset &quot;gcc-c-app&quot; : $sources, $includes, $cflags,
                                    $libraries, $ldflags, &quot;here_unittest&quot; ;


    here-test.prologue() {
        $sources.ls(&quot;.*\\.c@@bodyquot;);
        $ldflags = hefesto.sys.get_option(&quot;ldflags&quot;);
        $ldflags.add_item(&quot;../lib/libhere.a&quot;);
        $includes = hefesto.sys.get_option(&quot;includes&quot;);
        $includes = hefesto.sys.get_option(&quot;libraries&quot;);
        $includes = hefesto.sys.get_option(&quot;cflags&quot;);
    }

    function run_unittests() : result type int {
        var retval type int;
        if (hefesto.sys.os_name() != &quot;windows&quot;) {
            $retval = hefesto.sys.run(&quot;bin/here_unittest&quot;);
        } else {
            $retval = hefesto.sys.run(&quot;bin\\here_unittest.exe&quot;);
        }
        result $retval;
    }

    here-test.epilogue() {
        if (hefesto.sys.last_forge_result() == 0) {
            if (run_unittests() != 0) hefesto.sys.exit(1);
        }
    }
</code></pre>">    include ~/toolsets/gcc/gcc-app.hsl

    var sources type list;
    var includes type list;
    var libraries type list;
    var ldflags type list;
    var cflags type list;

    project here-test : toolset "gcc-c-app" : $sources, $includes, $cflags,
                                    $libraries, $ldflags, "here_unittest" ;


    here-test.prologue() {
        $sources.ls(".*\\.c$");
        $ldflags = hefesto.sys.get_option("ldflags");
        $ldflags.add_item("../lib/libhere.a");
        $includes = hefesto.sys.get_option("includes");
        $includes = hefesto.sys.get_option("libraries");
        $includes = hefesto.sys.get_option("cflags");
    }

    function run_unittests() : result type int {
        var retval type int;
        if (hefesto.sys.os_name() != "windows") {
            $retval = hefesto.sys.run("bin/here_unittest");
        } else {
            $retval = hefesto.sys.run("bin\\here_unittest.exe");
        }
        result $retval;
    }

    here-test.epilogue() {
        if (hefesto.sys.last_forge_result() == 0) {
            if (run_unittests() != 0) hefesto.sys.exit(1);
        }
    }
</code></pre><p>A função mais importante é a <code>run_unittests</code> chamada à partir do <code>epilogue</code> caso retorne algo diferente de zero sai com código 1, o que fará o <em>build</em> quebrar.</p><p>Eu posso dizer que encontrei meu paraíso no <code>Hades</code>… :) Espero que você continue motivado(a) e siga com a seção que te ensina de fato programar na <code>HSL</code> e possa tirar proveito do suporte e liberdade que esse aplicativo procura promover.</p><h2 id="sobre-a-hsl"><a name="sobre-a-hsl" href="#sobre-a-hsl"></a>Sobre a HSL</h2><p>Não era a minha intenção inicial criar uma <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> para o <em>Hefesto</em>, o fato é que cheguei a conclusão disso durante o processo de maturação da ideia. Visto que desejava resolver meus problemas de uma forma mais geral.</p><p>Em resumo, tive mais trabalho, contudo, hoje consigo expressar uma boa quantidade de automatizações para diversos processos que vão além de simplesmente fazer <em>builds</em> de projetos <em>C/C++</em>.</p><h3 id="por-que-uma-*dsl*-e-não-*scriptar*-uma-que-já-existe?"><a name="por-que-uma-*dsl*-e-não-*scriptar*-uma-que-já-existe?" href="#por-que-uma-*dsl*-e-não-*scriptar*-uma-que-já-existe?"></a>Por que uma <em>dsl</em> e não <em>scriptar</em> uma que já existe?</h3><p>Ao meu ver, o problema de usar uma linguagem de uso geral é fazer o usuário do <em>software</em> se preocupar com convenções gerais que em suma não são importantes para expressar suas necessidades. Fora que isso cria uma dependência externa o que te faz ser refém das decisões futuras de um outro projeto. Linguagens de uso geral abrem margem para muitas possibilidades, muitas possibilidades abrem margem para desordem.</p><h3 id="definindo-as-bases"><a name="definindo-as-bases" href="#definindo-as-bases"></a>Definindo as bases</h3><p>A <code>HSL</code> em momento nenhum esquece que é uma linguagem feita em suma para automatizar coisas, não comece querer programar <em>software</em> de uso geral com ela. <ins>Por favor não…</ins></p><p>Ela possui 4 tipos primitivos e não existe uma conveniência para se utilizar <em>user-defined types</em>, a <strong>Tabela 2</strong> sumariza esses tipos.</p><p><strong>Tabela 2</strong>: Tipos primitivos presentes na <code>HSL</code>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Palavra reservada</strong></th>
<th style="text-align:center"><strong>Tipo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">Inteiro de 32/64 bits</td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">Sequência de caracteres</td>
</tr>
<tr>
<td style="text-align:center"><code>file</code></td>
<td style="text-align:center">Um descritor de arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>list</code></td>
<td style="text-align:center">Container para dados do tipo <code>int</code> ou <code>string</code></td>
</tr>
</tbody>
</table><p>Fato: variáveis precisam ser declaradas.</p><p>Em qualquer ponto de um código <code>HSL</code> você pode declarar uma variável sob o seguinte esquema:</p><blockquote>
<p><strong>var</strong> <code>&lt;var-name&gt;</code> <strong>type</strong> <code>&lt;type-name&gt;</code> <strong>;</strong></p>
</blockquote><p>Saiba que <code>&lt;var-name&gt;</code> pode ser composto por <code>[A-Za-z0-9_]</code>. Pode-se ter uma e somente uma declaração por linha.</p><p>Exemplos práticos:</p><pre><code data-origin="<pre><code>    var my_name type string;
    var my_age type int ;
    var my_sloopy_list_decl
    type
    list;
</code></pre>">    var my_name type string;
    var my_age type int ;
    var my_sloopy_list_decl
    type
    list;
</code></pre><p>Para acessar uma variável declarada (me desculpe o pleonasmo) preceda-a com o símbolo <code>$</code>, assim:</p><pre><code data-origin="<pre><code>    $my_name = &quot;John doe.&quot;;
    $my_age = -1;
</code></pre>">    $my_name = "John doe.";
    $my_age = -1;
</code></pre><p><code>Branches</code> condicionais podem ser expressos da seguinte forma:</p><blockquote>
<p><strong>if</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong> [ <strong>else</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong> ]</p>
</blockquote><p>ou</p><blockquote>
<p><strong>if</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <code>&lt;hsl-single-stmt&gt;</code> [ <strong>else</strong> <code>&lt;hsl-single-stmt&gt;</code> ]</p>
</blockquote><p>Só existe uma forma de expressar <code>loops</code> na Linguagem que é via <code>while</code>, segue o formato dele:</p><blockquote>
<p><strong>while</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong></p>
</blockquote><p>ou</p><blockquote>
<p><strong>while</strong> <strong>(</strong> <code>&lt;expr&gt;</code> <strong>)</strong> <code>&lt;hsl-single-stmt&gt;</code></p>
</blockquote><p>A <strong>Tabela 3</strong> reúne os operadores disponíveis para compor expressões na <code>HSL</code>.</p><p><strong>Tabela 3</strong>: Operadores disponíveis até o momento.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Operador</strong></th>
<th style="text-align:center"><strong>Operação</strong></th>
<th style="text-align:center"><strong>Tipo</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">Igual a</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">Diferente de</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">Menor que</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">Maior que</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">Maior ou igual que</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">Menor ou igual a</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">.E.</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">.OU.</td>
<td style="text-align:center">Lógico</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">.E.</td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">.OU.</td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>Left Shift</code></td>
<td style="text-align:center">Bitwise</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>Right Shift</code></td>
<td style="text-align:center">Bitwise</td>
</tr>
</tbody>
</table><p>Funções podem retornar qualquer tipo primitivo ou nada. O esquema geral de declaração é:</p><blockquote>
<p><strong>function</strong> <code>&lt;function-name&gt;</code> <strong>(</strong> <code>&lt;var-decl-list&gt;</code> <strong>)</strong> <strong>: result type </strong> <strong>{</strong> <code>&lt;hsl-stmt&gt;</code> <strong>}</strong></p>
</blockquote><p>Os caracteres aceitos para <code>nomenclatura de uma função</code> <strong>são os mesmos</strong> aceitos para <code>nomenclatura de variáveis</code>.</p><p>Um exemplo mais prático… Uma função que calcula de forma recurssiva o fatorial de um número fornecido:</p><pre><code data-origin="<pre><code>    function fatorial(n type int) : result type int {
        if ($n == 0) return 1;
        return fatorial($n - 1) * $n;
    }
</code></pre>">    function fatorial(n type int) : result type int {
        if ($n == 0) return 1;
        return fatorial($n - 1) * $n;
    }
</code></pre><p>Uma função que não retorna nada, cujo <code>return type</code> deve ser <code>none</code>:</p><pre><code data-origin="<pre><code>    function say_hello() : result type none
    {
        hefesto.sys.echo(&quot;Hello, creative mind....\n&quot;)
    }
</code></pre>">    function say_hello() : result type none
    {
        hefesto.sys.echo("Hello, creative mind....\n")
    }
</code></pre><h3 id="as-*hefesto-syscalls*"><a name="as-*hefesto-syscalls*" href="#as-*hefesto-syscalls*"></a>As <em>Hefesto Syscalls</em></h3><p>Certo, o último exemplo com uma função inútil que só dizia alô, não foi tão inútil… Serviu para te criar uma dúvida:</p><blockquote>
<p>“O que afinal de contas é esse negócio de <code>hefesto.sys.whatever</code>??”</p>
</blockquote><p>Nada é por acaso nessa vida, acredite! Uma <em><a href="http://en.wikipedia.org/wiki/Eastern_mole#/media/File:ScalopusAquaticus.jpg">abominável</a> <a href="https://what-if.xkcd.com/4/">doninha</a> documentadora</em> pôs aquilo lá para fazer você tropeçar e cair aqui…. Quando comecei pensar a <code>HSL</code> uma das minhas principais indagações eram sobre o que é comum a quase todo processo de <em>build</em> e dessas coisas comuns, o que é direta ou indiretamente requisitado ao <code>Sistema Operacional</code> em questão.</p><p>Essas indagações me levaram criar uma camada de abstração que garante escrever passos comuns em uma <em>build-task</em> mas heterogêneos em termos práticos de um <code>OS</code> para outro, apenas uma vez e ter a garantia que rodarão iguais em qualquer plataforma suportada pelo <code>Hefesto</code>.</p><p>Essa camada de abstração pode ser acessada à partir do <code>subsistema sys</code> do <code>Hefesto</code>, da seguinte forma:</p><blockquote>
<p><code>hefesto.sys.&lt;sys-call&gt;(&lt;arg-list&gt;)</code></p>
</blockquote><p>Esse <code>subsistema</code> é chamado de <code>syscalls</code>, mas aqui não se deixe levar pelo conceito clássico de <em>syscall</em>. De fato, você encontrará muito mais do que <em>“syscalls”</em>. Encontrará coisas que fazem muito mais numa única chamada e num nível bem mais alto do que as boas e velhas <em>syscalls</em> do nosso bom e velho <em>Unix</em>, por exemplo.</p><p>Escolhi esse nome, porque durante meu trabalho notei que a maioria dos pontos de não portabilidade de uma <em>build-task</em> recaiam na maior parte sobre algumas <em>syscalls</em> verdadeiras. Então, fica aqui explicada a origem de qualquer futuro equívoco.</p><p>Uma outra forma de aceitar a não ortodoxia das <code>hefesto syscalls</code> pode ser entendendo que elas também englobam operações comuns de serem requisitadas e por isso postas de forma <code>built-in</code> no <em>build-system</em>. Criando o que eu aqui gosto de chamar de <code>subsistema</code>.</p><p>Na <strong>Tabela 4</strong> segue uma listagem com uma rápida descrição do que uma referida <code>syscall</code> faz.</p><p><strong>Tabela 4</strong>: <code>Hefesto  syscalls</code> disponíveis até o presente momento.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Syscall</strong></th>
<th style="text-align:right"><strong>Utilitade</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>replace_in_file()</code></td>
<td style="text-align:right">substitui um texto encontrado via uma expressão regular</td>
</tr>
<tr>
<td style="text-align:center"><code>lines_from_file()</code></td>
<td style="text-align:right">filtra linhas que casam com a expressão regular passada</td>
</tr>
<tr>
<td style="text-align:center"><code>ls()</code></td>
<td style="text-align:right">retorna a contagem de arquivos encontrados no diretório corrente que casam seus nomes com a regex fornecida</td>
</tr>
<tr>
<td style="text-align:center"><code>pwd()</code></td>
<td style="text-align:right">retorna o fullpath do diretório corrente</td>
</tr>
<tr>
<td style="text-align:center"><code>cd()</code></td>
<td style="text-align:right">muda o diretório corrente para o caminho passado</td>
</tr>
<tr>
<td style="text-align:center"><code>rm()</code></td>
<td style="text-align:right">remove o filepath fornecido</td>
</tr>
<tr>
<td style="text-align:center"><code>cp()</code></td>
<td style="text-align:right">copia um arquivo/diretório de um path existente para outro</td>
</tr>
<tr>
<td style="text-align:center"><code>mkdir()</code></td>
<td style="text-align:right">cria um diretório</td>
</tr>
<tr>
<td style="text-align:center"><code>rmdir()</code></td>
<td style="text-align:right">remove um diretório vazio</td>
</tr>
<tr>
<td style="text-align:center"><code>fopen()</code></td>
<td style="text-align:right">abre um arquivo retornando seu descritor que deve ser atribuído a uma variável do tipo file</td>
</tr>
<tr>
<td style="text-align:center"><code>fwrite()</code></td>
<td style="text-align:right">escreve dados para o arquivo referenciado pelo descritor de arquivo fornecido</td>
</tr>
<tr>
<td style="text-align:center"><code>fread()</code></td>
<td style="text-align:right">lê dados do arquivo referenciado pelo descritor de arquivo fornecido</td>
</tr>
<tr>
<td style="text-align:center"><code>fclose()</code></td>
<td style="text-align:right">limpa todos os recursos alocados por um descritor de arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>feof()</code></td>
<td style="text-align:right">verifica se é o final do arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek()</code></td>
<td style="text-align:right">pula para um determinado offset do arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek_to_begin()</code></td>
<td style="text-align:right">pula para o início do arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>fseek_to_end()</code></td>
<td style="text-align:right">pula para o final do arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>fsize()</code></td>
<td style="text-align:right">retorna o tamanho do arquivo em bytes</td>
</tr>
<tr>
<td style="text-align:center"><code>ftell()</code></td>
<td style="text-align:right">retorna o offset corrente do arquivo</td>
</tr>
<tr>
<td style="text-align:center"><code>run()</code></td>
<td style="text-align:right">roda um processo externo, retornando seu exit code</td>
</tr>
<tr>
<td style="text-align:center"><code>echo()</code></td>
<td style="text-align:right">escreve texto na tela</td>
</tr>
<tr>
<td style="text-align:center"><code>env()</code></td>
<td style="text-align:right">retorna o conteúdo de uma variável de ambiente</td>
</tr>
<tr>
<td style="text-align:center"><code>prompt()</code></td>
<td style="text-align:right">lê dados do teclado, esperando a confirmação via “ENTER”</td>
</tr>
<tr>
<td style="text-align:center"><code>exit()</code></td>
<td style="text-align:right">aborta a máquina virtual do hefesto, alterando o error level para o valor fornecido</td>
</tr>
<tr>
<td style="text-align:center"><code>os_name()</code></td>
<td style="text-align:right">retorna o nome da plataforma corrente</td>
</tr>
<tr>
<td style="text-align:center"><code>get_option()</code></td>
<td style="text-align:right">retorna dados de uma opção fornecida via linha de comando</td>
</tr>
<tr>
<td style="text-align:center"><code>make_path()</code></td>
<td style="text-align:right">cria uma string que corresponde a um caminho no sistema de arquivos</td>
</tr>
<tr>
<td style="text-align:center"><code>last_forge_result()</code></td>
<td style="text-align:right">obtém o exit code do último processo de forja executado</td>
</tr>
<tr>
<td style="text-align:center"><code>forge()</code></td>
<td style="text-align:right">invoca um outro projeto de forja</td>
</tr>
<tr>
<td style="text-align:center"><code>byref()</code></td>
<td style="text-align:right">atualiza os valores de um argumento de função para a variável externa que foi passada como esse argumento local</td>
</tr>
<tr>
<td style="text-align:center"><code>time()</code></td>
<td style="text-align:right">retorna uma string representando o tempo do sistema de acordo com o formato passado</td>
</tr>
<tr>
<td style="text-align:center"><code>setenv()</code></td>
<td style="text-align:right">cria uma variável de ambiente</td>
</tr>
<tr>
<td style="text-align:center"><code>unsetenv()</code></td>
<td style="text-align:right">remove uma variável de ambiente</td>
</tr>
<tr>
<td style="text-align:center"><code>call_from_module()</code></td>
<td style="text-align:right">chama uma função implementada em uma biblioteca dinâmica</td>
</tr>
<tr>
<td style="text-align:center"><code>get_func_addr()</code></td>
<td style="text-align:right">obtém o endereço de um nome de função passado</td>
</tr>
<tr>
<td style="text-align:center"><code>call_func_addr()</code></td>
<td style="text-align:right">tenta fazer uma chamada de função à partir do endereço passado</td>
</tr>
</tbody>
</table><h4 id="um-guia-prático-para-cada-*hefesto-syscall*"><a name="um-guia-prático-para-cada-*hefesto-syscall*" href="#um-guia-prático-para-cada-*hefesto-syscall*"></a>Um guia prático para cada <em>Hefesto syscall</em></h4><p>Aqui nessa parte você pode explorar melhor como usar cada <code>syscall</code>, vendo que argumentos recebem e o que retornam. Tudo isso de um modo mais prático.</p><h5 id="++replace_in_file()++"><a name="++replace_in_file()++" href="#++replace_in_file()++"></a><ins>replace_in_file()</ins></h5><p>Substitui dados em um arquivo. O primeiro argumento deve ser o <code>file path</code>, o segundo é o padrão de busca expresso por uma <code>regex</code>, o terceiro é o texto de substituição desejado.</p><pre><code data-origin="<pre><code>    function replace_in_file_sample() : result type none {
         hefesto.sys.replace_in_file(&quot;test.txt&quot;, &quot;^foo.*&quot;, &quot;all initial foo to bar&quot;);
    }
</code></pre>">    function replace_in_file_sample() : result type none {
         hefesto.sys.replace_in_file("test.txt", "^foo.*", "all initial foo to bar");
    }
</code></pre><h5 id="++lines_from_file()++"><a name="++lines_from_file()++" href="#++lines_from_file()++"></a><ins>lines_from_file()</ins></h5><p>Filtra linhas de um arquivo. O primeiro argumento deve ser o <code>file path</code>, o segundo é o padrão de busca expresso por uma <code>regex</code>. A <code>syscall</code> retorna uma lista contendo as linhas filtradas do arquivo.</p><pre><code data-origin="<pre><code>    function lines_from_file_sample() : result type none {
         var retval type list;
         $retval = hefesto.sys.lines_from_file(&quot;test.txt&quot;, &quot;^foo.*&quot;);
    }
</code></pre>">    function lines_from_file_sample() : result type none {
         var retval type list;
         $retval = hefesto.sys.lines_from_file("test.txt", "^foo.*");
    }
</code></pre><h5 id="++ls()++"><a name="++ls()++" href="#++ls()++"></a><ins>ls()</ins></h5><p>Lista arquivos no diretório corrente. Recebe somente um argumento que deve ser o padrão de listagem em <code>regex</code>.</p><pre><code data-origin="<pre><code>    function ls_sample() : result type none {
         if (hefesto.sys.ls(&quot;.*(c|cpp|s|asm)@@bodyquot;) &amp;gt; 0) {
              hefesto.sys.echo(&quot;Hey Beavis, Huh cool files to delete here!! Yeah yeah! Butt-head remove them! remove them!\n&quot;);
         } else {
              hefesto.sys.echo(&quot;ohh, nothing to screw up here.\n&quot;);
         }
    }
</code></pre>">    function ls_sample() : result type none {
         if (hefesto.sys.ls(".*(c|cpp|s|asm)$") &gt; 0) {
              hefesto.sys.echo("Hey Beavis, Huh cool files to delete here!! Yeah yeah! Butt-head remove them! remove them!\n");
         } else {
              hefesto.sys.echo("ohh, nothing to screw up here.\n");
         }
    }
</code></pre><h5 id="++pwd()++"><a name="++pwd()++" href="#++pwd()++"></a><ins>pwd()</ins></h5><p>Retorna o diretório corrente. É muito <code>DIFÍCIL</code> de usar essa função <code>built-in</code>, dê uma olhada:</p><pre><code data-origin="<pre><code>    function pwd_only_to_PHDs() : result type none {
         hefesto.sys.echo(&quot;The current work directory is: &quot; + hefesto.sys.pwd() + &quot;\n&quot;);
    }
</code></pre>">    function pwd_only_to_PHDs() : result type none {
         hefesto.sys.echo("The current work directory is: " + hefesto.sys.pwd() + "\n");
    }
</code></pre><h5 id="++cd()++"><a name="++cd()++" href="#++cd()++"></a><ins>cd()</ins></h5><p>Muda o <code>cwd</code> para o diretório fornecido via argumento.</p><pre><code data-origin="<pre><code>    function cd_sample() : result type none {
         hefesto.sys.cd(&quot;/home/rs&quot;);
    }
</code></pre>">    function cd_sample() : result type none {
         hefesto.sys.cd("/home/rs");
    }
</code></pre><h5 id="++rm()++"><a name="++rm()++" href="#++rm()++"></a><ins>rm()</ins></h5><p>Remove um arquivo.</p><pre><code data-origin="<pre><code>    function rm_sample() : result type none {
         hefesto.sys.rm(&quot;some.lint~&quot;);
    }
</code></pre>">    function rm_sample() : result type none {
         hefesto.sys.rm("some.lint~");
    }
</code></pre><h5 id="++cp()++"><a name="++cp()++" href="#++cp()++"></a><ins>cp()</ins></h5><p>Copia arquivo/diretórios para o diretório especificado. O primeiro argumento é o padrão regex correspondente ao source, o segundo é o destino.</p><pre><code data-origin="<pre><code>    function cp_sample() : result type none {
         hefesto.sys.cp(&quot;.*.(exe|dll|msi)&quot;, &quot;wpkg&quot;);
    }
</code></pre>">    function cp_sample() : result type none {
         hefesto.sys.cp(".*.(exe|dll|msi)", "wpkg");
    }
</code></pre><h5 id="++mkdir()++"><a name="++mkdir()++" href="#++mkdir()++"></a><ins>mkdir()</ins></h5><p>Cria o diretório sob o diretório de trabalho.</p><pre><code data-origin="<pre><code>    function mkdir_sample() : result type none {
         hefesto.sys.mkdir(&quot;wpkg&quot;);
    }
</code></pre>">    function mkdir_sample() : result type none {
         hefesto.sys.mkdir("wpkg");
    }
</code></pre><h5 id="++rmdir()++"><a name="++rmdir()++" href="#++rmdir()++"></a><ins>rmdir()</ins></h5><p>Remove um diretório vazio.</p><pre><code data-origin="<pre><code>    function rmdir_sample() : result type none {
         hefesto.sys.rmdir(&quot;stage&quot;);
    }
</code></pre>">    function rmdir_sample() : result type none {
         hefesto.sys.rmdir("stage");
    }
</code></pre><h5 id="++fopen()++"><a name="++fopen()++" href="#++fopen()++"></a><ins>fopen()</ins></h5><p>Abre um arquivo retornando o descritor que pode ser manipulado. O primeiro argumento é o <code>file path</code>, o segundo é o modo de abertura. Os modos seguem o <code>fopen</code> clássico da <code>libc</code> (“r” = somente leitura, “w” = somente escrita, “a” = modo <code>append</code>).</p><pre><code data-origin="<pre><code>    function fopen_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;a&quot;);
    }
</code></pre>">    function fopen_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "a");
    }
</code></pre><h5 id="++fwrite()++"><a name="++fwrite()++" href="#++fwrite()++"></a><ins>fwrite()</ins></h5><p>Escreve dados em um descritor de arquivo aberto com modo de escrita ou <code>append</code>. O primeiro argumento é o <code>buffer</code> de dados, o segundo é o quanto escrever desse <code>buffer</code>, o terceiro é o descritor de arquivo.</p><p>Retorna a quantidade de dados escritos no arquivo.</p><pre><code data-origin="<pre><code>    function fwrite_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;a&quot;);
         var buf type string;
         $buf = &quot;that's all folks for fwrite!\n&quot;;
         hefesto.sys.fwrite($buf, $buf.len(), $fp);
    }
</code></pre>">    function fwrite_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "a");
         var buf type string;
         $buf = "that's all folks for fwrite!\n";
         hefesto.sys.fwrite($buf, $buf.len(), $fp);
    }
</code></pre><h5 id="++fread()++"><a name="++fread()++" href="#++fread()++"></a><ins>fread()</ins></h5><p>Lê dados de um descritor de arquivo (óbvio: aberto em modo de leitura) avançando o ponteiro de arquivo por <em>n</em> <code>bytes</code> lidos. O primeiro argumento é o <code>buffer</code> de dados, o segundo é a quantidade que deve ser lida à partir do arquivo, o terceiro é o descritor.</p><p>Retorna a quantidade de dados lidos do arquivo.</p><pre><code data-origin="<pre><code>    function fread_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         var byte type string
         hefesto.sys.fread($byte, 1, $fp);
    }
</code></pre>">    function fread_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         var byte type string
         hefesto.sys.fread($byte, 1, $fp);
    }
</code></pre><h5 id="++fclose()++"><a name="++fclose()++" href="#++fclose()++"></a><ins>fclose()</ins></h5><p>Fecha/limpa os recursos internos associados ao descritor de arquivo. Recebe o descritor que deve ser fechado. É importante sempre chamar esta função depois de uma manipulação de arquivo. Seja higiêncio(a)!</p><pre><code data-origin="<pre><code>    function fclose_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;w&quot;);
         # TODO: do some manipulation here...
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fclose_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "w");
         # TODO: do some manipulation here...
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++feof()++"><a name="++feof()++" href="#++feof()++"></a><ins>feof()</ins></h5><p>Retorna <em>1</em> se o final do arquivo foi alcançado de outra forma <em>0</em>. Recebe o descritor de arquivo que deve ser verificado.</p><pre><code data-origin="<pre><code>    function feof_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         if (hefesto.sys.feof($fp) == 1) {
              hefesto.sys.echo(&quot;file end.\n&quot;);
        } else hefesto.sys.echo(&quot;NOT file end.\n&quot;);
             hefesto.sys.fclose($fp);
        }
    }
</code></pre>">    function feof_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         if (hefesto.sys.feof($fp) == 1) {
              hefesto.sys.echo("file end.\n");
        } else hefesto.sys.echo("NOT file end.\n");
             hefesto.sys.fclose($fp);
        }
    }
</code></pre><h5 id="++fseek()++"><a name="++fseek()++" href="#++fseek()++"></a><ins>fseek()</ins></h5><p>Pula para um <code>offset</code> específico do arquivo do início ao fim. O primeiro argumento é o descritor de arquivo, o segundo é o <code>offset</code> desejado.</p><pre><code data-origin="<pre><code>    function fseek_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek($fp, 10);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek($fp, 10);
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fseek_to_begin()++"><a name="++fseek_to_begin()++" href="#++fseek_to_begin()++"></a><ins>fseek_to_begin()</ins></h5><p>Pula para o início do arquivo. Recebe o descritor associado como argumento.</p><pre><code data-origin="<pre><code>    function fseek_to_begin_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek_to_begin($fp); # yes this is a very useless dummy sample...
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_to_begin_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek_to_begin($fp); # yes this is a very useless dummy sample...
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fseek_to_end()++"><a name="++fseek_to_end()++" href="#++fseek_to_end()++"></a><ins>fseek_to_end()</ins></h5><p>Pula para o final do arquivo. Recebe o descritor associado como argumento.</p><pre><code data-origin="<pre><code>    function fseek_to_end_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.fseek_to_end($fp);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fseek_to_end_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.fseek_to_end($fp);
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++fsize()++"><a name="++fsize()++" href="#++fsize()++"></a><ins>fsize()</ins></h5><p>Retorna os <code>bytes</code> totais de um arquivo associado ao descritor de arquivo passado.</p><pre><code data-origin="<pre><code>    function fsize_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.echo(&quot;The has &quot; + hefesto.sys.fsize($fp) + &quot;byte(s).\n&quot;);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function fsize_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.echo("The has " + hefesto.sys.fsize($fp) + "byte(s).\n");
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++ftell()++"><a name="++ftell()++" href="#++ftell()++"></a><ins>ftell()</ins></h5><p>Retorna o <code>offset</code> corrente do descritor de arquivo.</p><pre><code data-origin="<pre><code>    function ftell_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen(&quot;test.dat&quot;, &quot;r&quot;);
         hefesto.sys.echo(&quot;The current offset should be 0 and is &quot; + hefesto.sys.ftell($fp) + &quot;.\n&quot;);
         hefesto.sys.fclose($fp);
    }
</code></pre>">    function ftell_sample() : result type none {
         var fp type file;
         $fp = hefesto.sys.fopen("test.dat", "r");
         hefesto.sys.echo("The current offset should be 0 and is " + hefesto.sys.ftell($fp) + ".\n");
         hefesto.sys.fclose($fp);
    }
</code></pre><h5 id="++run()++"><a name="++run()++" href="#++run()++"></a><ins>run()</ins></h5><p>Roda um processo externo retornando o <code>exit code</code>. A chamada <code>run</code> é sempre bloqueante.</p><pre><code data-origin="<pre><code>    function sync_run_sample() : result type none {
         hefesto.sys.echo(&quot;ls /dev exits with &quot; + hefesto.sys.run(&quot;ls /dev&quot;) + &quot; exit code.\n&quot;);
    }
</code></pre>">    function sync_run_sample() : result type none {
         hefesto.sys.echo("ls /dev exits with " + hefesto.sys.run("ls /dev") + " exit code.\n");
    }
</code></pre><p>Você pode também rodar <em>n</em> processos se você passar para essa <code>syscall</code> uma lista contendo as linhas de execução. O número de processos concorrentes é controlado pela opção de linha de comando <code>--qsize=n</code>. Nesse modo, a <code>syscall run</code> retorna a soma dos <code>exit codes</code>.</p><pre><code data-origin="<pre><code>    function async_run_sample() : result type none {
         var wqueue type list;
         $wqueue.add_item(&quot;ls /dev&quot;);
         $wqueue.add_item(&quot;ls /home/rs&quot;);
         $wqueue.add_item(&quot;echo \&quot;duh!\&quot;&quot;);
         hefesto.sys.echo(&quot;The work queue exit code is &quot; + hefesto.sys.run($wqueue) + &quot;.\n&quot;);
    }
</code></pre>">    function async_run_sample() : result type none {
         var wqueue type list;
         $wqueue.add_item("ls /dev");
         $wqueue.add_item("ls /home/rs");
         $wqueue.add_item("echo \"duh!\"");
         hefesto.sys.echo("The work queue exit code is " + hefesto.sys.run($wqueue) + ".\n");
    }
</code></pre><h5 id="++echo()++"><a name="++echo()++" href="#++echo()++"></a><ins>echo()</ins></h5><p>Exibe uma <code>string</code> na tela. De fato é uma <code>Hefesto syscall</code> muito complicada.</p><pre><code data-origin="<pre><code>    function echo_sample() : result type none {
         hefesto.sys.echo(&quot;Hello world.\n&quot;);
    }
</code></pre>">    function echo_sample() : result type none {
         hefesto.sys.echo("Hello world.\n");
    }
</code></pre><h5 id="++env()++"><a name="++env()++" href="#++env()++"></a><ins>env()</ins></h5><p>Obtém o conteúdo de uma variável de ambiente.</p><pre><code data-origin="<pre><code>    function env_sample() : result type none {
         hefesto.sys.echo(&quot;The current content of Windows PATH variable is = \&quot;&quot; + hefesto.sys.env(&quot;PATH&quot;) + &quot;\&quot;\n&quot;);
    }
</code></pre>">    function env_sample() : result type none {
         hefesto.sys.echo("The current content of Windows PATH variable is = \"" + hefesto.sys.env("PATH") + "\"\n");
    }
</code></pre><h5 id="++prompt()++"><a name="++prompt()++" href="#++prompt()++"></a><ins>prompt()</ins></h5><p>Lê um valor do teclado. Retornando os dados lidos.</p><pre><code data-origin="<pre><code>    function prompt_sample() : result type none {
         var usr_data type string;
         $usr_data = hefesto.sys.prompt(&quot;Type about an idea and then press enter to confirm this: \n&quot;);
         hefesto.sys.echo(&quot;Hey I had an idea: &quot; + $usr_data + &quot;\nWhat do you think?&quot;);
    }
</code></pre>">    function prompt_sample() : result type none {
         var usr_data type string;
         $usr_data = hefesto.sys.prompt("Type about an idea and then press enter to confirm this: \n");
         hefesto.sys.echo("Hey I had an idea: " + $usr_data + "\nWhat do you think?");
    }
</code></pre><h5 id="++exit()++"><a name="++exit()++" href="#++exit()++"></a><ins>exit()</ins></h5><p>Aborta a execução da <code>HVM</code> saindo com o código passado.</p><pre><code data-origin="<pre><code>    function exit_sample() : result type none {
         hefesto.sys.exit(1);
    }
</code></pre>">    function exit_sample() : result type none {
         hefesto.sys.exit(1);
    }
</code></pre><h5 id="++os_name()++"><a name="++os_name()++" href="#++os_name()++"></a><ins>os_name()</ins></h5><p>Retorna o nome do sistema operacional onde seu <code>HSL</code> está correndo. O retorno é sempre o nome em <code>lower-case</code> e sem qualquer informação de versão.</p><pre><code data-origin="<pre><code>    function env_sample() : result type none {
         if (hefesto.sys.os_name() == &quot;windows&quot;) {
              hefesto.sys.echo(&quot;The current content of Windows PATH variable is = \&quot;&quot; + hefesto.sys.env(&quot;PATH&quot;) + &quot;\&quot;\n&quot;);
         }
    }
</code></pre>">    function env_sample() : result type none {
         if (hefesto.sys.os_name() == "windows") {
              hefesto.sys.echo("The current content of Windows PATH variable is = \"" + hefesto.sys.env("PATH") + "\"\n");
         }
    }
</code></pre><h5 id="++get_option()++"><a name="++get_option()++" href="#++get_option()++"></a><ins>get_option()</ins></h5><p>Obtém um argumento da linha de comando. Retorna uma lista contendo um ou mais valores ou uma lista vazia.</p><pre><code data-origin="<pre><code>    function get_option_sample() : result type none {
         var cups_of_tea type list;
         $cups_of_tea = hefesto.sys.get_option(&quot;cups-of-tea&quot;);
         if ($cups_of_tea.size() == 0)
              hefesto.sys.echo(&quot;--cups-of-tea option not supplied.\n&quot;);
         else
              hefesto.sys.echo(&quot;--cups-of-tea option supplied.\n&quot;);
    }
</code></pre>">    function get_option_sample() : result type none {
         var cups_of_tea type list;
         $cups_of_tea = hefesto.sys.get_option("cups-of-tea");
         if ($cups_of_tea.size() == 0)
              hefesto.sys.echo("--cups-of-tea option not supplied.\n");
         else
              hefesto.sys.echo("--cups-of-tea option supplied.\n");
    }
</code></pre><h5 id="++make_path()++"><a name="++make_path()++" href="#++make_path()++"></a><ins>make_path()</ins></h5><p>Cria uma <code>string path</code>. O primeiro argumento é o <code>root path</code>, o segundo é o <em>“addendum”</em> do <code>path</code>. Retorna a combinação correta.</p><pre><code data-origin="<pre><code>    function make_path_sample() : result type none {
         hefesto.sys.echo(&quot;STRING PATH must be /home/rs \&quot;&quot; + hefesto.sys.make_path(&quot;/home&quot;, &quot;/rs&quot;) + &quot;\&quot;\n.&quot;);
    }
</code></pre>">    function make_path_sample() : result type none {
         hefesto.sys.echo("STRING PATH must be /home/rs \"" + hefesto.sys.make_path("/home", "/rs") + "\"\n.");
    }
</code></pre><h5 id="++last_forge_result()++"><a name="++last_forge_result()++" href="#++last_forge_result()++"></a><ins>last_forge_result()</ins></h5><p>Obtém o último resultado de forja (este resultado pode ser alterado pela <code>syscall exit</code>).</p><pre><code data-origin="<pre><code>    function last_forge_result_sample() : result type none {
         hefesto.sys.echo(&quot;The last forge result was &quot; + hefesto.sys.last_forge_result() + &quot;.\n&quot;);
    }
</code></pre>">    function last_forge_result_sample() : result type none {
         hefesto.sys.echo("The last forge result was " + hefesto.sys.last_forge_result() + ".\n");
    }
</code></pre><h5 id="++forge()++"><a name="++forge()++" href="#++forge()++"></a><ins>forge()</ins></h5><p>Invoca um projeto de forja. O primeiro argumento é o nome do projeto contido no <code>HSL</code> informado via primeiro argumento. O terceiro argumento são as opções de usuário.</p><pre><code data-origin="<pre><code>    function forge_sample() : result type none {
         hefesto.sys.forge(&quot;foolib&quot;, &quot;local_deps.hsl&quot;, &quot;--user-includes-home=../alt_incs --pre-submit-me&quot;);
         if (hefesto.sys.last_forge_result() == 0) {
              hefesto.sys.echo(&quot;foolib built with success.\n&quot;);
         } else {
              hefesto.sys.echo(&quot;unable to build foolib.\n&quot;);
              hefesto.sys.exit(1);
         }
    }
</code></pre>">    function forge_sample() : result type none {
         hefesto.sys.forge("foolib", "local_deps.hsl", "--user-includes-home=../alt_incs --pre-submit-me");
         if (hefesto.sys.last_forge_result() == 0) {
              hefesto.sys.echo("foolib built with success.\n");
         } else {
              hefesto.sys.echo("unable to build foolib.\n");
              hefesto.sys.exit(1);
         }
    }
</code></pre><h5 id="++byref()++"><a name="++byref()++" href="#++byref()++"></a><ins>byref()</ins></h5><p>Atualiza os valores de um argumento local de função para uma variável externa que foi passada como esse argumento. Deve ser passada a variável local exata que deve ser atualizada para a variável externa.</p><pre><code data-origin="<pre><code>    function caller() : result type none {
         var return type string;
         $return = &quot;foo&quot;;
         hefesto.sys.echo($return);
         byref_sample($return);
         hefesto.sys.echo($return + &quot;\n&quot;);
    }
    function byref_sample(io_var type string) : result type none {
         $io_var = &quot;bar&quot;;
         hefesto.sys.byref($io_var);
    }
</code></pre>">    function caller() : result type none {
         var return type string;
         $return = "foo";
         hefesto.sys.echo($return);
         byref_sample($return);
         hefesto.sys.echo($return + "\n");
    }
    function byref_sample(io_var type string) : result type none {
         $io_var = "bar";
         hefesto.sys.byref($io_var);
    }
</code></pre><h5 id="++time()++"><a name="++time()++" href="#++time()++"></a><ins>time()</ins></h5><p>Retorna uma <code>string</code> representando o tempo do sistema de acordo com o formato passado. Os formatos aceitos são os mesmos aceitos pela função <code>strftime()</code> contida na <code>libc</code> de seu <code>OS</code>.</p><pre><code data-origin="<pre><code>    function time_sample() : result type none {
         hefesto.sys.echo(&quot;Current time: &quot; + hefesto.sys.time(&quot;%H:%M&quot;) + &quot;\n&quot;);
    }
</code></pre>">    function time_sample() : result type none {
         hefesto.sys.echo("Current time: " + hefesto.sys.time("%H:%M") + "\n");
    }
</code></pre><h5 id="++setenv()++"><a name="++setenv()++" href="#++setenv()++"></a><ins>setenv()</ins></h5><p>Cria uma variável de ambiente. Após o término do processo a variável é perdida.</p><pre><code data-origin="<pre><code>    function setenv_sample() : result type none {
         hefesto.sys.setenv(&quot;mytempvar&quot;, &quot;mytempval&quot;);
    }
</code></pre>">    function setenv_sample() : result type none {
         hefesto.sys.setenv("mytempvar", "mytempval");
    }
</code></pre><p>No <code>Windows</code> você pode utilizar essa <code>syscall</code> para acessar o registro também, bastando informar o caminho completo onde deseja salvar o valor, precedendo essa informação pelo marcador <code>WINREG:</code>.</p><pre><code data-origin="<pre><code>    function setenv_sample() : result type none {
         hefesto.sys.setenv(&quot;WINREG:HKCU\\Software\\Abc\\mytempvar:REG_SZ&quot;, &quot;mytempval&quot;);
    }
</code></pre>">    function setenv_sample() : result type none {
         hefesto.sys.setenv("WINREG:HKCU\\Software\\Abc\\mytempvar:REG_SZ", "mytempval");
    }
</code></pre><h5 id="++unsetenv()++"><a name="++unsetenv()++" href="#++unsetenv()++"></a><ins>unsetenv()</ins></h5><p>Remove uma variável de ambiente. O processo de remoção somente afeta o processo referente a aplicação.</p><pre><code data-origin="<pre><code>    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv(&quot;VSCOMPILERPATH&quot;);
    }
</code></pre>">    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv("VSCOMPILERPATH");
    }
</code></pre><p>No <code>Windows</code> você pode utilizar essa syscall para remover valores do registro também (essa remoção é permanente). Da seguinte forma:</p><pre><code data-origin="<pre><code>    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv(&quot;WINREG:HKLM\\Software\\Abc\\mytempvar&quot;);
    }
</code></pre>">    function unsetenv_sample() : result type none {
         hefesto.sys.unsetenv("WINREG:HKLM\\Software\\Abc\\mytempvar");
    }
</code></pre><h5 id="++call_from_module()++"><a name="++call_from_module()++" href="#++call_from_module()++"></a><ins>call_from_module()</ins></h5><p>Chama uma função implementada numa biblioteca dinâmica.</p><p>O módulo precisa conter funções implementadas utilizando uma estrutura de dados especial. Mais informações sobre isso podem ser encontradas no documento destinado a especificar os detalhes de implementação de módulos para o hefesto.</p><pre><code data-origin="<pre><code>    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_moduke(&quot;/usr/share/mymods/my_killer_mod.so&quot;, &quot;killer_func&quot;, &quot;arg1&quot;, &quot;arg2&quot;, 3);
    }
</code></pre>">    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_moduke("/usr/share/mymods/my_killer_mod.so", "killer_func", "arg1", "arg2", 3);
    }
</code></pre><p>Você pode usar indireção de paths para localizar um módulo, caso não queira indicar o <code>path</code> completo para ele em seu código <code>HSL</code>:</p><pre><code data-origin="<pre><code>    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module(&quot;~/my_killer_mod.so&quot;, &quot;killer_func&quot;, &quot;arg1&quot;, &quot;arg2&quot;, 3);
    }
</code></pre>">    function call_from_module_sample() : result type none {
         hefesto.sys.call_from_module("~/my_killer_mod.so", "killer_func", "arg1", "arg2", 3);
    }
</code></pre><p>Nesse exemplo apresentado, a biblioteca <code>"my_killer_mod.so"</code> será procurada nos <code>paths</code> configurados na variável de ambiente <code>HEFESTO_MODULES_HOME</code>.</p><h5 id="++get_func_addr()++"><a name="++get_func_addr()++" href="#++get_func_addr()++"></a><ins>get_func_addr()</ins></h5><p>Obtém o endereço de um nome de função informado.</p><pre><code data-origin="<pre><code>    function get_func_addr_sample() : result type int {
         result hefesto.sys.get_func_addr(&quot;dummy_clbk&quot;);
    }
</code></pre>">    function get_func_addr_sample() : result type int {
         result hefesto.sys.get_func_addr("dummy_clbk");
    }
</code></pre><h5 id="++call_func_addr()++"><a name="++call_func_addr()++" href="#++call_func_addr()++"></a><ins>call_func_addr()</ins></h5><p>Tenta fazer uma chamada de função à partir de um endereço específico. Se qualquer erro ocorrer no processo um erro de tempo de execução é disparado.</p><pre><code data-origin="<pre><code>    function call_func_addr_sample() : result type int {
         var clbk_p type int;
         $clbk_p = hefesto.sys.get_func_addr(&quot;abc_one_two_three&quot;);
         result hefesto.sys.call_from_addr($clbk_p, &quot;abc&quot;, 1, &quot;two&quot;, 3);
    }
</code></pre>">    function call_func_addr_sample() : result type int {
         var clbk_p type int;
         $clbk_p = hefesto.sys.get_func_addr("abc_one_two_three");
         result hefesto.sys.call_from_addr($clbk_p, "abc", 1, "two", 3);
    }
</code></pre><h3 id="os-facilitadores-dos-tipos-*list*-e-*string*"><a name="os-facilitadores-dos-tipos-*list*-e-*string*" href="#os-facilitadores-dos-tipos-*list*-e-*string*"></a>Os facilitadores dos tipos <em>list</em> e <em>string</em></h3><p>Talvez você fique tentado(a) em chamar os facilitadores de métodos, porém, a <code>HSL</code> não é uma Linguagem orientada à objetos, de forma que os facilitadores podem ser entendidos como operações comuns de serem feitas sobre esses tipos de dados e que por serem comuns por motivos de performance foram implementadas de forma <em>built-in</em> na <code>HSL</code>.</p><p>A <strong>Tabela 5</strong> traz uma listagem dos facilitadores presentes no tipo <code>string</code>. A <strong>Tabela 6</strong> reúne os facilitadores implementados no tipo <code>list</code>.</p><p><strong>Tabela 5</strong>: Os facilitadores <code>string-type</code>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Facilitador</strong></th>
<th style="text-align:right"><strong>Utilidade</strong></th>
<th style="text-align:center"><strong>Exemplo de chamada</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>at</code></td>
<td style="text-align:right">Retorna o <em>byte</em> presente no índice fornecido</td>
<td style="text-align:center">$str.at(0)</td>
</tr>
<tr>
<td style="text-align:center"><code>len</code></td>
<td style="text-align:right">Retorna o tamanho da <em>string</em></td>
<td style="text-align:center">$str.len()</td>
</tr>
<tr>
<td style="text-align:center"><code>match</code></td>
<td style="text-align:right">Busca por um padrão <em>regex</em> dentro da <em>string</em></td>
<td style="text-align:center">$str.match(“.*”)</td>
</tr>
<tr>
<td style="text-align:center"><code>replace</code></td>
<td style="text-align:right">Substitui um padrão <em>regex</em> dentro da <em>string</em></td>
<td style="text-align:center">$str.replace(“.*”, “nothing”)</td>
</tr>
</tbody>
</table><p><strong>Tabela 6</strong>: Os facilitadores <code>list-type</code>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Facilitador</strong></th>
<th style="text-align:right"><strong>Utilidade</strong></th>
<th style="text-align:center"><strong>Exemplo de chamada</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>item</code></td>
<td style="text-align:right">Retorna o item presente no índice passado</td>
<td style="text-align:center">$lst.item(0)</td>
</tr>
<tr>
<td style="text-align:center"><code>count</code></td>
<td style="text-align:right">Retorna o total de itens presentes na lista</td>
<td style="text-align:center">$lst.count()</td>
</tr>
<tr>
<td style="text-align:center"><code>add_item</code></td>
<td style="text-align:right">Adiciona um item</td>
<td style="text-align:center">$lst.add_item(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>del_item</code></td>
<td style="text-align:right">Remove um item baseado no conteúdo passado</td>
<td style="text-align:center">$lst.del_item(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>del_index</code></td>
<td style="text-align:right">Remove o item presente no índice passado</td>
<td style="text-align:center">$lst.del_index(1)</td>
</tr>
<tr>
<td style="text-align:center"><code>ls</code></td>
<td style="text-align:right">Carrega os <em>paths</em> de arquivos que se encaixam na <em>regex</em> passada</td>
<td style="text-align:center">$lst.ls(“.*\\.c$”)</td>
</tr>
<tr>
<td style="text-align:center"><code>clear</code></td>
<td style="text-align:right">Limpa a lista</td>
<td style="text-align:center">$lst.clear()</td>
</tr>
<tr>
<td style="text-align:center"><code>index_of</code></td>
<td style="text-align:right">Retorna o índice de um conteúdo passado ou -1</td>
<td style="text-align:center">$lst.index_of(“1”)</td>
</tr>
<tr>
<td style="text-align:center"><code>swap</code></td>
<td style="text-align:right">Altera a posição de dois items baseados nos seus índices</td>
<td style="text-align:center">$lst.swap(0,9)</td>
</tr>
</tbody>
</table><h4 id="exemplos-usando-esses-facilitadores"><a name="exemplos-usando-esses-facilitadores" href="#exemplos-usando-esses-facilitadores"></a>Exemplos usando esses facilitadores</h4><p>Seguem alguns:</p><pre><code data-origin="<pre><code>function get_filepaths_from_directories(dir type list, regex type string) :
                                                            return type list {
    var d type int;
    var dirpath type string;
    var oldcwd type string;
    var retval type list;
    $oldcwd = hefesto.sys.pwd();
    $d = 0;
    while ($d &amp;lt; $dir.count()) {
        $dirpath = $dir.item($d);
        if (hefesto.sys.cd($dirpath) == 1) {
            $retval.ls($regex);
        }
        $d = $d + 1;
    }
    hefesto.sys.cd($oldcwd);
    result $retval;
}
</code></pre>">function get_filepaths_from_directories(dir type list, regex type string) :
                                                            return type list {
    var d type int;
    var dirpath type string;
    var oldcwd type string;
    var retval type list;
    $oldcwd = hefesto.sys.pwd();
    $d = 0;
    while ($d &lt; $dir.count()) {
        $dirpath = $dir.item($d);
        if (hefesto.sys.cd($dirpath) == 1) {
            $retval.ls($regex);
        }
        $d = $d + 1;
    }
    hefesto.sys.cd($oldcwd);
    result $retval;
}
</code></pre><p>Exemplo de chamada:</p><blockquote>
<p><code>var dir type list;</code></p>
<p><code>var os_name type string;</code></p>
<p><code>$os_name = hefesto.sys.os_name();</code></p>
<p><code>$dir.add_item(".");</code></p>
<p><code>$dir.add_item("native/" + $os_name);</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/fs");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/net");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/mm");</code></p>
<p><code>$dir.add_item("native/" + $os_name + "/ps");</code></p>
<p><code>$dir.add_item("common/");</code></p>
<p><code>$dir.add_item("common/fs");</code></p>
<p><code>$dir.add_item("common/net");</code></p>
<p><code>$dir.add_item("common/mm");</code></p>
<p><code>$dir.add_item("common/ps");</code></p>
<p><code>var files type list;</code></p>
<p><code>$files = get_filepaths_from_directories($dir, "*.\\.c$");</code></p>
</blockquote><pre><code data-origin="<pre><code>function piglatinize(said type string) : result type string {
    var s type int;
    var etvalray type string;
    var punctoken type list;
    var curr_symbol type string;
    var curr_word type string;

    if ($said.match(&quot;[0123456789]&quot;) == 1) {
        hefesto.sys.echo(&quot;ANICPAY: I can't handle numbers... aieeeeeeee!!\n&quot;);
        result &quot;(ullnay)&quot;; # no way: &quot;nil&quot; is not piglatin!!!! :D
    }

    $punctoken.add_item(&quot; &quot;);
    $punctoken.add_item(&quot;,&quot;);
    $punctoken.add_item(&quot;;&quot;);
    $punctoken.add_item(&quot;.&quot;);
    $punctoken.add_item(&quot;?&quot;);
    $punctoken.add_item(&quot;!&quot;);
    $s = 0;
    while ($s &amp;lt; $said.len()) {
        $curr_symbol = $said.at($s);
        if (($s + 1) == $said.len()) {
            if ($punctoken.index_of($curr_symbol) == -1) {
                $curr_word = $curr_word + $curr_symbol;
                $curr_symbol = &quot;.&quot;;
            }
        }
        if ($punctoken.index_of($curr_symbol) &amp;gt; -1) {
            if ($curr_word.len() &amp;gt; 1) {
                var first_letter type string;
                var second_letter type string;
                $first_letter = $curr_word.at(0);
                $second_letter = $curr_word.at(1);
                var ss type int;
                $ss = 2;
                $etvalray = $etvalray + $second_letter;
                while ($ss &amp;lt; $curr_word.len()) {
                    $etvalray = $etvalray + $curr_word.at($ss);
                    $ss = $ss + 1;
                }
                $etvalray = $etvalray + tolower($first_letter);
            } else {}
                $etvalray = $etvalray + $curr_word;
            }
            if ($curr_word.len() &amp;gt; 0) {
                $etvalray = $etvalray + &quot;ay&quot;;
            }
            $etvalray = $etvalray + $curr_symbol;
            $curr_word = &quot;&quot;;
        } else {
            $curr_word = $curr_word + $said.at($s);
        }
        $s = $s + 1;
    }
    result $etvalray;
}

function tolower(l type string) : result type string {
    var letters type list;
    $letters.add_item(&quot;A&quot;);
    $letters.add_item(&quot;B&quot;);
    $letters.add_item(&quot;C&quot;);
    $letters.add_item(&quot;D&quot;);
    $letters.add_item(&quot;E&quot;);
    $letters.add_item(&quot;F&quot;);
    $letters.add_item(&quot;G&quot;);
    $letters.add_item(&quot;H&quot;);
    $letters.add_item(&quot;I&quot;);
    $letters.add_item(&quot;K&quot;);
    $letters.add_item(&quot;K&quot;);
    $letters.add_item(&quot;L&quot;);
    $letters.add_item(&quot;M&quot;);
    $letters.add_item(&quot;N&quot;);
    $letters.add_item(&quot;O&quot;);
    $letters.add_item(&quot;P&quot;);
    $letters.add_item(&quot;Q&quot;);
    $letters.add_item(&quot;R&quot;);
    $letters.add_item(&quot;S&quot;);
    $letters.add_item(&quot;T&quot;);
    $letters.add_item(&quot;U&quot;);
    $letters.add_item(&quot;V&quot;);
    $letters.add_item(&quot;W&quot;);
    $letters.add_item(&quot;X&quot;);
    $letters.add_item(&quot;Y&quot;);
    $letters.add_item(&quot;Z&quot;);
    $letters.add_item(&quot;a&quot;);
    $letters.add_item(&quot;b&quot;);
    $letters.add_item(&quot;c&quot;);
    $letters.add_item(&quot;d&quot;);
    $letters.add_item(&quot;e&quot;);
    $letters.add_item(&quot;f&quot;);
    $letters.add_item(&quot;g&quot;);
    $letters.add_item(&quot;h&quot;);
    $letters.add_item(&quot;i&quot;);
    $letters.add_item(&quot;j&quot;);
    $letters.add_item(&quot;k&quot;);
    $letters.add_item(&quot;l&quot;);
    $letters.add_item(&quot;m&quot;);
    $letters.add_item(&quot;n&quot;);
    $letters.add_item(&quot;o&quot;);
    $letters.add_item(&quot;p&quot;);
    $letters.add_item(&quot;q&quot;);
    $letters.add_item(&quot;r&quot;);
    $letters.add_item(&quot;s&quot;);
    $letters.add_item(&quot;t&quot;);
    $letters.add_item(&quot;u&quot;);
    $letters.add_item(&quot;v&quot;);
    $letters.add_item(&quot;w&quot;);
    $letters.add_item(&quot;x&quot;);
    $letters.add_item(&quot;y&quot;);
    $letters.add_item(&quot;z&quot;);
    var l_index type int;
    $l_index =  $letters.index_of($l);
    if ($l_index &amp;gt; -1 &amp;amp;&amp;amp; $l_index &amp;lt; 26) {
        var lower_letter type string;
        $lower_letter = $letters.item($l_index + 26);
        result $lower_letter;
    }
    result $l;
}
</code></pre>">function piglatinize(said type string) : result type string {
    var s type int;
    var etvalray type string;
    var punctoken type list;
    var curr_symbol type string;
    var curr_word type string;

    if ($said.match("[0123456789]") == 1) {
        hefesto.sys.echo("ANICPAY: I can't handle numbers... aieeeeeeee!!\n");
        result "(ullnay)"; # no way: "nil" is not piglatin!!!! :D
    }

    $punctoken.add_item(" ");
    $punctoken.add_item(",");
    $punctoken.add_item(";");
    $punctoken.add_item(".");
    $punctoken.add_item("?");
    $punctoken.add_item("!");
    $s = 0;
    while ($s &lt; $said.len()) {
        $curr_symbol = $said.at($s);
        if (($s + 1) == $said.len()) {
            if ($punctoken.index_of($curr_symbol) == -1) {
                $curr_word = $curr_word + $curr_symbol;
                $curr_symbol = ".";
            }
        }
        if ($punctoken.index_of($curr_symbol) &gt; -1) {
            if ($curr_word.len() &gt; 1) {
                var first_letter type string;
                var second_letter type string;
                $first_letter = $curr_word.at(0);
                $second_letter = $curr_word.at(1);
                var ss type int;
                $ss = 2;
                $etvalray = $etvalray + $second_letter;
                while ($ss &lt; $curr_word.len()) {
                    $etvalray = $etvalray + $curr_word.at($ss);
                    $ss = $ss + 1;
                }
                $etvalray = $etvalray + tolower($first_letter);
            } else {}
                $etvalray = $etvalray + $curr_word;
            }
            if ($curr_word.len() &gt; 0) {
                $etvalray = $etvalray + "ay";
            }
            $etvalray = $etvalray + $curr_symbol;
            $curr_word = "";
        } else {
            $curr_word = $curr_word + $said.at($s);
        }
        $s = $s + 1;
    }
    result $etvalray;
}

function tolower(l type string) : result type string {
    var letters type list;
    $letters.add_item("A");
    $letters.add_item("B");
    $letters.add_item("C");
    $letters.add_item("D");
    $letters.add_item("E");
    $letters.add_item("F");
    $letters.add_item("G");
    $letters.add_item("H");
    $letters.add_item("I");
    $letters.add_item("K");
    $letters.add_item("K");
    $letters.add_item("L");
    $letters.add_item("M");
    $letters.add_item("N");
    $letters.add_item("O");
    $letters.add_item("P");
    $letters.add_item("Q");
    $letters.add_item("R");
    $letters.add_item("S");
    $letters.add_item("T");
    $letters.add_item("U");
    $letters.add_item("V");
    $letters.add_item("W");
    $letters.add_item("X");
    $letters.add_item("Y");
    $letters.add_item("Z");
    $letters.add_item("a");
    $letters.add_item("b");
    $letters.add_item("c");
    $letters.add_item("d");
    $letters.add_item("e");
    $letters.add_item("f");
    $letters.add_item("g");
    $letters.add_item("h");
    $letters.add_item("i");
    $letters.add_item("j");
    $letters.add_item("k");
    $letters.add_item("l");
    $letters.add_item("m");
    $letters.add_item("n");
    $letters.add_item("o");
    $letters.add_item("p");
    $letters.add_item("q");
    $letters.add_item("r");
    $letters.add_item("s");
    $letters.add_item("t");
    $letters.add_item("u");
    $letters.add_item("v");
    $letters.add_item("w");
    $letters.add_item("x");
    $letters.add_item("y");
    $letters.add_item("z");
    var l_index type int;
    $l_index =  $letters.index_of($l);
    if ($l_index &gt; -1 &amp;&amp; $l_index &lt; 26) {
        var lower_letter type string;
        $lower_letter = $letters.item($l_index + 26);
        result $lower_letter;
    }
    result $l;
}
</code></pre><p>Exemplo de chamada:</p><blockquote>
<p><code>hefesto.sys.echo(piglatinize("I like to speak pig latin.") + "\n");</code></p>
</blockquote><h3 id="o-subsistema-*project*"><a name="o-subsistema-*project*" href="#o-subsistema-*project*"></a>O subsistema <em>project</em></h3><p>Esse subsistema reúne informações sobre o projeto de forja atualmente executado pelo <em>Hefesto</em> e pode ser acessado de qualquer ponto da forja, ou seja, de dentro do <code>toolset</code>, de fora, não importa.</p><p>As funções apresentadas na <strong>Tabela 7</strong> podem ser acessadas à partir de:</p><blockquote>
<p><code>hefesto.project.&lt;function-name&gt;(&lt;args&gt;)</code></p>
</blockquote><p><strong>Tabela 7</strong>: Funções presentes no subsistema <code>project</code>.</p><table>
<thead>
<tr>
<th style="text-align:center"><strong>Função</strong></th>
<th style="text-align:center"><strong>Utilidade</strong></th>
<th style="text-align:right"><strong>Exemplo de chamada</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>name()</code></td>
<td style="text-align:center">Retorna o nome do projeto em execução</td>
<td style="text-align:right"><code>hefesto.project.name()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>toolset()</code></td>
<td style="text-align:center">Retorna o nome do toolset usado</td>
<td style="text-align:right"><code>hefesto.project.toolset()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>dep_chain()</code></td>
<td style="text-align:center">Retorna a <code>dep-chain</code> usada</td>
<td style="text-align:right"><code>hefesto.project.dep_chain()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>abort()</code></td>
<td style="text-align:center">Aborta o projeto</td>
<td style="text-align:right"><code>hefesto.project.abort(1)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>cmdline()</code></td>
<td style="text-align:center">Retorna a linha de comando que a forja está sendo baseada</td>
<td style="text-align:right"><code>hefesto.project.cmdline()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>file_path()</code></td>
<td style="text-align:center">Retorna o <code>file path</code> do arquivo do projeto em execução</td>
<td style="text-align:right"><code>hefesto.project.file_path()</code></td>
</tr>
</tbody>
</table><h3 id="tem-uma-forma-fácil-de-rodar-esses-exemplos-e-brincar-com-a-linguagem-para-eu-me-habituar?!"><a name="tem-uma-forma-fácil-de-rodar-esses-exemplos-e-brincar-com-a-linguagem-para-eu-me-habituar?!" href="#tem-uma-forma-fácil-de-rodar-esses-exemplos-e-brincar-com-a-linguagem-para-eu-me-habituar?!"></a>Tem uma forma fácil de rodar esses exemplos e brincar com a Linguagem para eu me habituar?!</h3><p>Sim, claro! Quando você instala o <code>Hefesto</code> juntamente com os <code>toolsets</code> padrão ele instala um <code>toolset</code> <a href="https://github.com/rafael-santiago/helios/blob/master/src/include/doc/toolsets/null/README.md">oco</a>, a função de forja apenas retorna o número que você passa na declaração do projeto. Com isso, você pode chamar o que quiser dentro dos <code>entry-points</code> do projeto que criar baseado nesse <code>toolset-stub</code>.</p><h3 id="onde-posso-continuar-explorando-a-*hsl*?"><a name="onde-posso-continuar-explorando-a-*hsl*?" href="#onde-posso-continuar-explorando-a-*hsl*?"></a>Onde posso continuar explorando a <em>HSL</em>?</h3><p>A <code>HSL</code> possui um repositório próprio de códigos chamado <a href="https://github.com/rafael-santiago/helios.git">Helios</a>, ele inclusive foi baixado junto com o repositório do <code>Hefesto</code> em sua máquina e uma parte que julgo básica dele já está instalada. Por padrão, ele traz documentações acerca de seus módulos. É uma boa dar uma lida nesses documentos caso queira saber mais sobre funções de apoio que você já possui à sua disposição. Em termos práticos, o <code>Helios</code> pode ser entendido como o diretório de <code>includes</code> do <code>Hefesto</code> criado na cópia que você instalou.</p><p>Existe uma coleção de códigos dentro do <em>Helios</em> que são as <a href="https://github.com/rafael-santiago/helios/blob/master/src/include/doc/hc/README.md">hc-functions</a>, com elas é possível verificar se o ambiente onde será executada a forja possui todos os requisitos necessários para isso. Essas bibliotecas de funções <code>HSL</code> permite que você crie um <em>build</em> mais “parrudo”. Seria interessante para quem deseja uma tolerância maior para diferentes <em>build-environments</em>, de forma a ter um <em>build</em> mais no estado da arte.</p><h3 id="tirando-as-rodinhas:-criando-*hefesto-toolsets*-e-dominando-completamente-o-*build-system*"><a name="tirando-as-rodinhas:-criando-*hefesto-toolsets*-e-dominando-completamente-o-*build-system*" href="#tirando-as-rodinhas:-criando-*hefesto-toolsets*-e-dominando-completamente-o-*build-system*"></a>Tirando as rodinhas: criando <em>Hefesto toolsets</em> e dominando completamente o <em>build-system</em></h3><p>Se você leu as outras seções e tentou rodar os exemplos, falta um passo para você se tornar um usuário avançado do <code>Hefesto</code>, porque até o momento você está apto(a) em automatizar passos no sua própria <em>build-task</em> e usar os <code>toolsets</code> “de fábrica”. O que te garante o <code>status</code> de usuário final estando ainda dependente de um <a href="http://en.wikipedia.org/wiki/Tasmanian_Devil_(Looney_Tunes"><code>toolset devel</code></a>).</p><p>Nisso, eu te convido a aprender como se implementa um <code>Hefesto toolset</code>. Se você até o momento está gostando da proposta do aplicativo, após as informações contidas nessa seção, talvez goste mais e se sinta motivado(a) em criar extensões para ele, levando em consideração suas próprias necessidades (o que é uma das principais linhas mestras desse projeto. <em>Liberdade para criar</em>. <em>Clareza em se expressar</em>. <em>Generalidade ao usar</em>.).</p><h4 id="mas-antes:-uma-breve-recapitulação-de-tudo-que-já-foi-visto"><a name="mas-antes:-uma-breve-recapitulação-de-tudo-que-já-foi-visto" href="#mas-antes:-uma-breve-recapitulação-de-tudo-que-já-foi-visto"></a>Mas antes: uma breve recapitulação de tudo que já foi visto</h4><p>O que você já conferiu e/ou já sabe:</p><ul>
<li>O <code>Hefesto</code> é um <em>build system</em> que busca dar clareza e liberdade para escrever de forma organizada uma <em>build-task</em>.</li><li>Ele implementa uma <em>dsl</em> que é usada tanto nas extensões que podem ser feitas em uma <em>build-task</em> específica quanto nas generalidades que englobam qualquer <em>build-task</em> do mesmo tipo, neste caso tais generalidades nele são denominadas <code>toolsets</code>.</li><li>Foi apresentada a parte da <code>HSL</code> que recai sobre a declaração de um projeto.</li><li>Foram apresentados códigos exemplificando o reuso de <code>toolsets</code> previamente escritos.</li><li>Também foram apresentadas diferentes formas de disparar o <em>build</em> (forja) de um projeto.</li><li>Foi visto como monitorar mudanças nos arquivos que compõem um projeto.</li><li>Uma visão geral, no contexto de usuário, sobre as <code>dep-chains</code> foi apresentada.</li><li>Foi mostrado como incluir passos adicionais ao processo de forja, sendo usado para isso o exemplo da necessidade de se disparar e avaliar o resultado de <em>unit tests</em>.</li><li>A possibilidade de se criar um <em>Forgefile</em> mais maleável cuja a escolha de um <code>toolset</code> específico é feita em <em>runtime</em>, também foi vista.</li><li>Aspectos gerais sobre a <code>HSL</code> e seu subsistema <code>sys</code> foram detalhados.</li></ul><p>O que você ainda não conhece e depois de ler essa parte poderá dominar:</p><ul>
<li>Como declarar um <code>toolset</code>.</li><li>O subsistema <code>toolset</code>.</li><li>Como internamente o <code>Hefesto</code> sabe que um arquivo mudou.</li><li>O subsistema <code>project</code>.</li><li>Boas práticas para se criar e manter novos <code>toolsets</code>.</li></ul><h4 id="nossa-meta:-um-*toolset-gcc*-para-compilar-e-gerar-*aplicativos*-escritos-em-*c*"><a name="nossa-meta:-um-*toolset-gcc*-para-compilar-e-gerar-*aplicativos*-escritos-em-*c*" href="#nossa-meta:-um-*toolset-gcc*-para-compilar-e-gerar-*aplicativos*-escritos-em-*c*"></a>Nossa meta: um <em>toolset GCC</em> para compilar e gerar <em>aplicativos</em> escritos em <em>C</em></h4><p>Escolhi a Linguagem <em>C</em> por se tratar de uma Linguagem “compilada” e com dependências a serem resolvidas de forma externa ao compilador. Algumas Linguagens mais contemporâneas detectam essas dependências entre arquivos automaticamente, já a Linguagem <em>C</em> não, isso vai nos fazer pensar em muitos detalhes o que será um ótimo <strong>batismo de fogo no Hades</strong> ;) e aí? Pronto(a)?!</p><h5 id="descobrindo-quem-depende-de-quem..."><a name="descobrindo-quem-depende-de-quem..." href="#descobrindo-quem-depende-de-quem..."></a>Descobrindo quem depende de quem…</h5><p>Sim, seria bom que você para essa segunda parte trouxesse uma noção de <em>C</em>, mesmo que <em>newbie</em>. Estou levando em conta que o leitor dessa seção tem esse perfil.</p><p>Imagine um projeto em <em>C</em> cuja a função <code>main</code> é essa:</p><pre><code data-origin="<pre><code>    #include &quot;init.h&quot;
    #include &quot;config.h&quot;
    #include &quot;options.h&quot;
    #include &amp;lt;stdio.h&amp;gt;

    int main(int argc, char **argv) {
        if (argc &amp;gt; 1) {
            get_options(argv, argc);
        }
        if (do_config()) {
            printf(&quot;*** Started!\n&quot;);
            return init();
        }
        printf(&quot;*** Error.\n&quot;);
        return 1;
    }
</code></pre>">    #include "init.h"
    #include "config.h"
    #include "options.h"
    #include &lt;stdio.h&gt;

    int main(int argc, char **argv) {
        if (argc &gt; 1) {
            get_options(argv, argc);
        }
        if (do_config()) {
            printf("*** Started!\n");
            return init();
        }
        printf("*** Error.\n");
        return 1;
    }
</code></pre><p>Em <em>C</em> os <code>includes</code> dizem muito sobre as dependências diretas que um arquivo possui em relação aos outros. Geralmente, arquivos incluídos usando aspas duplas recaem sobre arquivos locais ao projeto e arquivos que utilizam o padrão <code>&lt; ... &gt;</code> são arquivos externos ao projeto.</p><p>À partir disso, vamos compor uma função que chegará à conclusão da <code>depchain</code> de qualquer projeto <em>C</em> que use esses moldes clássicos de inclusão de códigos. Convenhamos que indicar dependências manualmente é muito chato, contudo, esteja avisado(a) que a busca por dependências entre arquivos é algo heurístico de modo que não existe uma solução geral e completa. Eu pesquisei um pouco além da conta sobre isso durante a escrita do <code>Hefesto</code> e foi algo que até certo ponto tirou meu sono.</p><p>Qual é melhor forma na <code>HSL</code> de serializar o conteúdo de um arquivo em linhas? Eu voto na <code>syscall lines_from_file()</code>. Vou apresentar o código completo do <code>c-scanner</code> de dependências e depois discorro sobre o que achar relevante:</p><pre><code data-origin="<pre><code>include ~/fsutil.hsl

function get_c_cpp_deps() : result type string {
    var files type list;
    var includes type list;
    var f type int;
    var i type int;
    var dep_chain type string;
    var str type string;
    var cwd type string;
    var exts type list;
    var e type int;
    var dep_nr type int;
    var related_files type list;

    $e = 0;

    $exts.add_item(&quot;h&quot;);
    $exts.add_item(&quot;hpp&quot;);
    $exts.add_item(&quot;c&quot;);
    $exts.add_item(&quot;C&quot;);
    $exts.add_item(&quot;CC&quot;);
    $exts.add_item(&quot;cc&quot;);
    $exts.add_item(&quot;cpp&quot;);
    $exts.add_item(&quot;CPP&quot;);

    while ($e &amp;lt; $exts.count()) {
        $str = &quot;.*\\.&quot; + $exts.item($e) + &quot;@@bodyquot;;
        $files.ls($str);
        $f = 0;
        $cwd = hefesto.sys.pwd();
        while ($f &amp;lt; $files.count()) {
            $str = $files.item($f);
            $dep_chain = $dep_chain + $str + &quot;: &quot;;
            $includes = hefesto.sys.lines_from_file($str, &quot;#include.*@@bodyquot;);
            $i = 0;
            $dep_nr = 0;
            while ($i &amp;lt; $includes.count()) {
                $str = $includes.item($i);
                $str.replace(&quot;.*#include.*(\&quot;|&amp;lt;)&quot;, &quot;&quot;);
                $str.replace(&quot;(\&quot;|&amp;gt;)@@bodyquot;, &quot;&quot;);
                if (isfile($str) == 1) {
                    $str = hefesto.sys.make_path($cwd, $str);
                    if ($dep_nr &amp;gt; 0) {
                        $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
                    }
                    $dep_chain = $dep_chain + $str + &quot; &quot;;
                    $dep_nr = $dep_nr + 1;
                    }
                $i = $i + 1;
            }
            if ($exts.item($e) == &quot;h&quot; || $exts.item($e) == &quot;hpp&quot;) {
                $str = $files.item($f);
                $str = filenamefrompath($str);
                $str.replace(&quot;\\.(h|hpp)@@bodyquot;, &quot;&quot;);
                $related_files.clear();
                $related_files.ls(&quot;.*&quot; + filenamefrompath($str) + &quot;\\.(c|C|CC|cc|cpp|CPP)@@bodyquot;);
                if ($related_files.count() &amp;gt; 0) {
                    $i = 0;
                    while ($i &amp;lt; $related_files.count()) {
                        if ($dep_nr &amp;gt; 0) {
                            $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
                        }
                        $dep_chain = $dep_chain + $related_files.item($i) + &quot; &quot;;
                        $dep_nr = $dep_nr + 1;
                        $i = $i + 1;
                    }
                }
            }
            $dep_chain = $dep_chain + &quot;;\n&quot;;
            $f = $f + 1;
        }
        $files.clear();
        $e = $e + 1;
    }
    result $dep_chain;
}
</code></pre>">include ~/fsutil.hsl

function get_c_cpp_deps() : result type string {
    var files type list;
    var includes type list;
    var f type int;
    var i type int;
    var dep_chain type string;
    var str type string;
    var cwd type string;
    var exts type list;
    var e type int;
    var dep_nr type int;
    var related_files type list;

    $e = 0;

    $exts.add_item("h");
    $exts.add_item("hpp");
    $exts.add_item("c");
    $exts.add_item("C");
    $exts.add_item("CC");
    $exts.add_item("cc");
    $exts.add_item("cpp");
    $exts.add_item("CPP");

    while ($e &lt; $exts.count()) {
        $str = ".*\\." + $exts.item($e) + "$";
        $files.ls($str);
        $f = 0;
        $cwd = hefesto.sys.pwd();
        while ($f &lt; $files.count()) {
            $str = $files.item($f);
            $dep_chain = $dep_chain + $str + ": ";
            $includes = hefesto.sys.lines_from_file($str, "#include.*$");
            $i = 0;
            $dep_nr = 0;
            while ($i &lt; $includes.count()) {
                $str = $includes.item($i);
                $str.replace(".*#include.*(\"|&lt;)", "");
                $str.replace("(\"|&gt;)$", "");
                if (isfile($str) == 1) {
                    $str = hefesto.sys.make_path($cwd, $str);
                    if ($dep_nr &gt; 0) {
                        $dep_chain = $dep_chain + "&amp; ";
                    }
                    $dep_chain = $dep_chain + $str + " ";
                    $dep_nr = $dep_nr + 1;
                    }
                $i = $i + 1;
            }
            if ($exts.item($e) == "h" || $exts.item($e) == "hpp") {
                $str = $files.item($f);
                $str = filenamefrompath($str);
                $str.replace("\\.(h|hpp)$", "");
                $related_files.clear();
                $related_files.ls(".*" + filenamefrompath($str) + "\\.(c|C|CC|cc|cpp|CPP)$");
                if ($related_files.count() &gt; 0) {
                    $i = 0;
                    while ($i &lt; $related_files.count()) {
                        if ($dep_nr &gt; 0) {
                            $dep_chain = $dep_chain + "&amp; ";
                        }
                        $dep_chain = $dep_chain + $related_files.item($i) + " ";
                        $dep_nr = $dep_nr + 1;
                        $i = $i + 1;
                    }
                }
            }
            $dep_chain = $dep_chain + ";\n";
            $f = $f + 1;
        }
        $files.clear();
        $e = $e + 1;
    }
    result $dep_chain;
}
</code></pre><p>Sim, <em>parser</em> é algo trabalhoso por mais bobo que seja pois envolve dar suporte para algumas características encantadoras nos seres humanos: bagunça, desmanzelo e falta de padrão.</p><p>As linhas:</p><pre><code data-origin="<pre><code>    $exts.add_item(&quot;h&quot;);
    $exts.add_item(&quot;hpp&quot;);
    $exts.add_item(&quot;c&quot;);
    $exts.add_item(&quot;C&quot;);
    $exts.add_item(&quot;CC&quot;);
    $exts.add_item(&quot;cc&quot;);
    $exts.add_item(&quot;cpp&quot;);
    $exts.add_item(&quot;CPP&quot;);
</code></pre>">    $exts.add_item("h");
    $exts.add_item("hpp");
    $exts.add_item("c");
    $exts.add_item("C");
    $exts.add_item("CC");
    $exts.add_item("cc");
    $exts.add_item("cpp");
    $exts.add_item("CPP");
</code></pre><p>São responsáveis por registrar as extensões de arquivo relevantes de serem escaneados. Pelo fato de haver milhões de possibilidade para se nomear <code>headers</code> e <code>implementation files</code> precisamos de uma lista… Se o desenvolvedor usar <code>Hpp</code> e/ou <code>Cpp</code> hahah ele já era. Poderíamos também converter o <code>filepath</code> de um arquivo totalmente para minúsculas ou maiúsculas mas não quis fazer isso, se quiser, sinta-se livre.</p><p>Depois para cada extensão registrada, buscamos no diretório corrente via a função de lista <code>ls()</code> o seguinte padrão <code>Regex</code>:</p><pre><code data-origin="<pre><code>$str = &quot;.*\\.&quot; + $exts.item($e) + &quot;@@bodyquot;;
</code></pre>">$str = ".*\\." + $exts.item($e) + "$";
</code></pre><p>O que nas iterações poderá ser:</p><blockquote>
<p>“.*\\.h$”…</p>
<blockquote>
<p>“.*\\.hpp$”…</p>
<blockquote>
<p>“.*\\.c$”…</p>
<blockquote>
<p>“.*\\.C$”…</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote><p>Cada arquivo encontrado passa possuir um registro na <code>dep-chain</code> (lembra da sintaxe dela? então…). Dessa forma ele terá o conteúdo monitorado pelo <code>Hefesto</code>:</p><pre><code data-origin="<pre><code>$str = $files.item($f);
$dep_chain = $dep_chain + $str + &quot;: &quot;;
</code></pre>">$str = $files.item($f);
$dep_chain = $dep_chain + $str + ": ";
</code></pre><p>Depois o conteúdo desse arquivo é varrido em busca de diretivas includes:</p><pre><code data-origin="<pre><code>$includes = hefesto.sys.lines_from_file($str, &quot;#include.*@@bodyquot;);
</code></pre>">$includes = hefesto.sys.lines_from_file($str, "#include.*$");
</code></pre><p>Note que não é uma boa ancorar a <code>regex</code> com o <code>^</code>, pois pessoas tendem ser relapsas e digitarem <code>includes</code> nesse formato organizado:</p><blockquote>
<pre><code data-origin="<pre><code> #includes &quot;aqui.h&quot;
          #include &quot;lah.h&quot;
   /*vou incluir ali também*/ #include &quot;ali.h&quot;
</code></pre>"> #includes "aqui.h"
          #include "lah.h"
   /*vou incluir ali também*/ #include "ali.h"
</code></pre></blockquote><p>Com cada linha include encontrada, é extraído o nome do arquivo e gerado um <code>fullpath</code> com esse nome extraído precedido pelo <a href="http://en.wikipedia.org/wiki/Working_directory"><code>cwd</code></a>. Se esse arquivo for realmente acessível ele entra como uma dependência para o arquivo anteriormente registrado na <code>dep-chain</code>:</p><pre><code data-origin="<pre><code>while ($i &amp;lt; $includes.count()) {
    $str = $includes.item($i);
       $str.replace(&quot;.*#include.*(\&quot;|&amp;lt;)&quot;, &quot;&quot;);
       $str.replace(&quot;(\&quot;|&amp;gt;)@@bodyquot;, &quot;&quot;);
       if (isfile($str) == 1) {
           $str = hefesto.sys.make_path($cwd, $str);
        if ($dep_nr &amp;gt; 0) {
            $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
        }
        $dep_chain = $dep_chain + $str + &quot; &quot;;
        $dep_nr = $dep_nr + 1;
    }
    $i = $i + 1;
}
</code></pre>">while ($i &lt; $includes.count()) {
    $str = $includes.item($i);
       $str.replace(".*#include.*(\"|&lt;)", "");
       $str.replace("(\"|&gt;)$", "");
       if (isfile($str) == 1) {
           $str = hefesto.sys.make_path($cwd, $str);
        if ($dep_nr &gt; 0) {
            $dep_chain = $dep_chain + "&amp; ";
        }
        $dep_chain = $dep_chain + $str + " ";
        $dep_nr = $dep_nr + 1;
    }
    $i = $i + 1;
}
</code></pre><p>Para os <code>headers</code> essa função aplica uma busca secundária pelos arquivos de implementação deles. Se existirem e forem acessíveis sob o contexto do <code>cwd</code> as implementações também serão dependências, no caso, implícitas, de nosso arquivo atualmente escaneado:</p><pre><code data-origin="<pre><code>if ($exts.item($e) == &quot;h&quot; || $exts.item($e) == &quot;hpp&quot;) {
    $str = $files.item($f);
    $str = filenamefrompath($str);
    $str.replace(&quot;\\.(h|hpp)@@bodyquot;, &quot;&quot;);
    $related_files.clear();
    $related_files.ls(&quot;.*&quot; + filenamefrompath($str) + &quot;\\.(c|C|CC|cc|cpp|CPP)@@bodyquot;);
    if ($related_files.count() &amp;gt; 0) {
        $i = 0;
        while ($i &amp;lt; $related_files.count()) {
            if ($dep_nr &amp;gt; 0) {
                $dep_chain = $dep_chain + &quot;&amp;amp; &quot;;
            }
            $dep_chain = $dep_chain + $related_files.item($i) + &quot; &quot;;
            $dep_nr = $dep_nr + 1;
            $i = $i + 1;
        }
    }
}
</code></pre>">if ($exts.item($e) == "h" || $exts.item($e) == "hpp") {
    $str = $files.item($f);
    $str = filenamefrompath($str);
    $str.replace("\\.(h|hpp)$", "");
    $related_files.clear();
    $related_files.ls(".*" + filenamefrompath($str) + "\\.(c|C|CC|cc|cpp|CPP)$");
    if ($related_files.count() &gt; 0) {
        $i = 0;
        while ($i &lt; $related_files.count()) {
            if ($dep_nr &gt; 0) {
                $dep_chain = $dep_chain + "&amp; ";
            }
            $dep_chain = $dep_chain + $related_files.item($i) + " ";
            $dep_nr = $dep_nr + 1;
            $i = $i + 1;
        }
    }
}
</code></pre><p>Depois disso, o arquivo atual já terá todas as possíveis dependências devidamente listadas na <code>dep-chain</code> o que apenas resta fechar a declaração de suas dependências:</p><pre><code data-origin="<pre><code>$dep_chain = $dep_chain + &quot;;\n&quot;;
</code></pre>">$dep_chain = $dep_chain + ";\n";
</code></pre><p>Isso é repetido com cada arquivo presente no <code>cwd</code>, em outras palavras o diretório do projeto, ou o diretório atual de onde esse <code>c-scanner</code> de dependências foi chamado, note que é possível mudar o <code>cwd</code> com a <code>syscall cd</code> e então chamar o <code>scanner</code>.</p><p>Após todos os arquivos processados a <code>dep-chain</code> composta retorna para o chamador:</p><pre><code data-origin="<pre><code>    result $dep_chain;
</code></pre>">    result $dep_chain;
</code></pre><p>A qual provavelmente será usada na seção <code>dependencies</code> presente na declaração de um projeto.</p><p>Caso queira, volte na listagem total do código comentado e tente digerí-lo um pouco mais. Até se sentir confiante sobre o que cada linha faz.</p><h5 id="criando-o-toolset"><a name="criando-o-toolset" href="#criando-o-toolset"></a>Criando o toolset</h5><p>Um <code>toolset</code> precisa ser declarado. Na declaração de um <code>toolset</code> não apenas definimos por qual nome esse será chamado, mas também reunimos em sua declaração de forma geral tudo que ele fará usando ferramentas externas.</p><p>O que um <code>toolset</code> <em>C</em> precisa fazer que depende de <code>tools</code> externas?</p><ul>
<li>Compilar os códigos;</li><li>Linkeditá-los;</li></ul><p>Veja a declaração desse <code>toolset</code>:</p><pre><code data-origin="<pre><code>include ~/toolsets/gcc/forges/gcc_c_app_forge.hsl

toolset &quot;gcc-c-app&quot; forge function &quot;gcc_c_binary_forge&quot; :
    forge helpers &quot;gcc_compile_source_list&quot;,
                  &quot;gcc_link_ofiles&quot;, &quot;gcc_mk_app_compilation_command&quot;:
    command &quot;compile_r&quot;: SOURCE, OUTFILE, INCLUDES, CFLAGS &amp;lt;
        gcc -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &amp;gt;
    command &quot;compile_d&quot;: SOURCE, OUTFILE, INCLUDES, CFLAGS &amp;lt;
        gcc -g -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &amp;gt;
    command &quot;link_shared&quot;: APPNAME, OBJECTS, LIBRARIES, LDFLAGS &amp;lt;
        gcc -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &amp;gt;
    command &quot;link_static&quot;: APPNAME, OBJECTS, LIBRARIES, LDFLAGS &amp;lt;
        gcc -static -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &amp;gt;
$
</code></pre>">include ~/toolsets/gcc/forges/gcc_c_app_forge.hsl

toolset "gcc-c-app" forge function "gcc_c_binary_forge" :
    forge helpers "gcc_compile_source_list",
                  "gcc_link_ofiles", "gcc_mk_app_compilation_command":
    command "compile_r": SOURCE, OUTFILE, INCLUDES, CFLAGS &lt;
        gcc -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &gt;
    command "compile_d": SOURCE, OUTFILE, INCLUDES, CFLAGS &lt;
        gcc -g -c $SOURCE $INCLUDES $CFLAGS -o $OUTFILE
    &gt;
    command "link_shared": APPNAME, OBJECTS, LIBRARIES, LDFLAGS &lt;
        gcc -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &gt;
    command "link_static": APPNAME, OBJECTS, LIBRARIES, LDFLAGS &lt;
        gcc -static -o$APPNAME $OBJECTS $LIBRARIES $LDFLAGS
    &gt;
$
</code></pre><p>A sintaxe básica de declaração é:</p><blockquote>
<p><code>toolset &lt;string-name&gt; forge function &lt;hsl-function-name&gt; : [forge helpers &lt;helpers-list&gt;] : &lt;command-templates&gt; $</code></p>
</blockquote><p>No exemplo apresentado, o <code>toolset</code> se chama: <code>gcc-c-app</code>. Sua função de forja é <code>gcc_c_binary_forge</code>, isso explica a diretiva <code>include</code> no início do exemplo, pois é nele que está definida a função de forja em questão. Os ajudantes de forja (funções <code>HSL</code>) são: <code>gcc_compile_list</code>, <code>gcc_link_ofiles</code> e <code>gcc_mk_compilation_command</code>. Uma declaração de <code>toolset</code> sempre termina com o símbolo de final de fita (<code>$</code>).</p><p>Os <code>templates de comando</code> que esse <code>toolset</code> implementa são: <code>compile_r</code>, <code>compile_d</code>, <code>link_shared</code> e <code>link_static</code>. Um template de comando nada mais é do que uma abstração de um comando externo que o seu <code>toolset</code> irá montar. Segue a sintaxe de declaração dessa parte:</p><blockquote>
<p><code>command &lt;string-name&gt; : &lt;string-argument-list&gt; &lt; &lt;command-line template&gt; &gt;</code></p>
</blockquote><p>Importante notar que um <code>comando de toolset</code> <strong>sempre</strong> recebe <em>strings</em> como argumento e retorna uma <em>string</em>, baseada em seu <code>command-line template</code> com os argumentos passados expandidos nele.</p><p>Existe uma regra bem estrita quanto a acessibilidade desses comandos de <code>toolset</code>:</p><blockquote>
<p>Somente podem ser acessados pela função de forja do <code>toolset</code> ou pelas funções ajudantes de forja.</p>
</blockquote><p>Mas agora, como acessar esses comandos de <code>toolset</code>?</p><p>Muito simples, você os acessa à partir do subsistema <code>toolset</code>. Imagine o <code>toolset</code> apresentado, para acessar o comando <code>compile_r</code> é necessário:</p><blockquote>
<p>(…)<br><code>$cmd = hefesto.toolset.compile_r($source_path, $outfile_path, $includes, $cflags);</code><br>(…)</p>
</blockquote><p>Uma boa abordagem no início da criação de um <code>toolset</code> é se perguntar quais comandos externos esse <code>toolset</code> necessitará executar. Acho que essa é a gênese de qualquer <code>toolset</code>.</p><h5 id="a-função-de-forja"><a name="a-função-de-forja" href="#a-função-de-forja"></a>A função de forja</h5><p>Talvez essa seja a parte mais trabalhosa do trajeto, pois é na função de forja que deve ser incutida a lógica do <em>build</em>. Levando em consideração que um <code>toolset</code> deve ser uma generalização de tarefas que usem os comandos externos do <code>toolset</code> para produzirem alguma coisa e ainda serem utilizados por mais de uma pessoa…</p><p>Segue a função de forja, depois da listagem, comentarei as partes que julgar relevantes:</p><pre><code data-origin="<pre><code>function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int {
    var exit_code type int;
    var includes type string;
    var cflags type string;
    var libraries type string;
    var ldflags type string;
    var objects type string;

    if ($SOURCES.count() == 0) {
        if (hefesto.project.toolset() == &quot;gcc-c-app&quot;) {
            $SOURCES.ls(&quot;.*\\.c@@bodyquot;);
        } else {
            $SOURCES.ls(&quot;.*\\.(cc|cpp|CC|Cpp|CPP)@@bodyquot;);
        }
    }

    if ($SOURCES.count() == 0) {
        hefesto.sys.echo(&quot;\t(empty source list)\n&quot;);
        result 1;
    }

    var obj_output_dir type list;
    var obj_dir type string;

    $obj_output_dir = hefesto.sys.get_option(&quot;obj-output-dir&quot;);
    if ($obj_output_dir.count() &amp;gt; 0) {
        $obj_dir = $obj_output_dir.item(0);
        mktree($obj_dir);
    } else {
        $obj_dir = hefesto.sys.pwd();
    }

    var bin_output_dir type list;
    var bin_output type string;

    $bin_output_dir = hefesto.sys.get_option(&quot;bin-output-dir&quot;);
    if ($bin_output_dir.count() &amp;gt; 0) {
        $bin_output = $bin_output_dir.item(0);
        mktree($bin_output);
        $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
    } else {
        $bin_output = $APPNAME;
    }

    $exit_code = 0;

    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES); 

    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options

    var cpu_arch type list;
    var chosen_arch type string;
    $cpu_arch = hefesto.sys.get_option(&quot;cpu-arch&quot;);
    $chosen_arch = &quot;&quot;;
    if ($cpu_arch.count() &amp;gt; 0) {
        $chosen_arch = $cpu_arch.item(0);
        if ($chosen_arch != &quot;32&quot; &amp;amp;&amp;amp; $chosen_arch != &quot;64&quot;) {
            hefesto.sys.echo(hefesto.project.toolset() +
                &quot; fatal error: invalid value for cpu-arch &quot; +
                &quot;option must be '32' or '64'.\n&quot;);
            result 1;
        }
        $cflags = $cflags + &quot; -m&quot; + $chosen_arch;
    }

    #  compiling...
    hefesto.sys.echo(&quot;*** compiling...\n&quot;);

    $exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
    if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;amp;&amp;amp; isfile($bin_output) == 0) {
        $gcc_c_project_forge_dirty_files_nr = 1;
    }

    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0 &amp;amp;&amp;amp; $exit_code == 0) {
        $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
        $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
        if ($chosen_arch.len() &amp;gt; 0) {
            $ldflags = $ldflags + &quot;-m&quot; + $chosen_arch;
        }
        $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
        #  linking...
        hefesto.sys.echo(&quot;*** now linking...\n\t*** waiting...\n&quot;);
        $exit_code = gcc_link_ofiles($objects,
                                     $libraries
                                     $ldflags,
                                     $bin_output);
    }

    if ($exit_code == 0) {
        hefesto.sys.echo(&quot;*** success.\n&quot;);
    } else {
        hefesto.sys.echo(&quot;*** failure.\n&quot;);
    }

    result $exit_code;
}
</code></pre>">function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int {
    var exit_code type int;
    var includes type string;
    var cflags type string;
    var libraries type string;
    var ldflags type string;
    var objects type string;

    if ($SOURCES.count() == 0) {
        if (hefesto.project.toolset() == "gcc-c-app") {
            $SOURCES.ls(".*\\.c$");
        } else {
            $SOURCES.ls(".*\\.(cc|cpp|CC|Cpp|CPP)$");
        }
    }

    if ($SOURCES.count() == 0) {
        hefesto.sys.echo("\t(empty source list)\n");
        result 1;
    }

    var obj_output_dir type list;
    var obj_dir type string;

    $obj_output_dir = hefesto.sys.get_option("obj-output-dir");
    if ($obj_output_dir.count() &gt; 0) {
        $obj_dir = $obj_output_dir.item(0);
        mktree($obj_dir);
    } else {
        $obj_dir = hefesto.sys.pwd();
    }

    var bin_output_dir type list;
    var bin_output type string;

    $bin_output_dir = hefesto.sys.get_option("bin-output-dir");
    if ($bin_output_dir.count() &gt; 0) {
        $bin_output = $bin_output_dir.item(0);
        mktree($bin_output);
        $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
    } else {
        $bin_output = $APPNAME;
    }

    $exit_code = 0;

    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES); 

    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options

    var cpu_arch type list;
    var chosen_arch type string;
    $cpu_arch = hefesto.sys.get_option("cpu-arch");
    $chosen_arch = "";
    if ($cpu_arch.count() &gt; 0) {
        $chosen_arch = $cpu_arch.item(0);
        if ($chosen_arch != "32" &amp;&amp; $chosen_arch != "64") {
            hefesto.sys.echo(hefesto.project.toolset() +
                " fatal error: invalid value for cpu-arch " +
                "option must be '32' or '64'.\n");
            result 1;
        }
        $cflags = $cflags + " -m" + $chosen_arch;
    }

    #  compiling...
    hefesto.sys.echo("*** compiling...\n");

    $exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
    if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;&amp; isfile($bin_output) == 0) {
        $gcc_c_project_forge_dirty_files_nr = 1;
    }

    if ($gcc_c_project_forge_dirty_files_nr &gt; 0 &amp;&amp; $exit_code == 0) {
        $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
        $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
        if ($chosen_arch.len() &gt; 0) {
            $ldflags = $ldflags + "-m" + $chosen_arch;
        }
        $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
        #  linking...
        hefesto.sys.echo("*** now linking...\n\t*** waiting...\n");
        $exit_code = gcc_link_ofiles($objects,
                                     $libraries
                                     $ldflags,
                                     $bin_output);
    }

    if ($exit_code == 0) {
        hefesto.sys.echo("*** success.\n");
    } else {
        hefesto.sys.echo("*** failure.\n");
    }

    result $exit_code;
}
</code></pre><p>Note que a função de forja tem a seguinte definição:</p><pre><code data-origin="<pre><code>function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int
</code></pre>">function gcc_c_binary_forge(SOURCES type list,
                            INCLUDES type list, CFLAGS type list,
                            LIBRARIES type list,
                            LDFLAGS type list,
                            APPNAME type string) : result type int
</code></pre><p>Isso explica a sequência/tipo dos argumentos passados na declaração do projeto:</p><pre><code data-origin="<pre><code>var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project sample : toolset &quot;gcc-c-app&quot; : $sources, $includes, $cflags,
                                       $libraries, $ldflags, &quot;sample&quot; ;
</code></pre>">var sources type list;
var includes type list;
var cflags type list;
var libraries type list;
var ldflags type list;

project sample : toolset "gcc-c-app" : $sources, $includes, $cflags,
                                       $libraries, $ldflags, "sample" ;
</code></pre><p>Esse <code>toolset</code> possui de cara uma conveniência:</p><pre><code data-origin="<pre><code>if ($SOURCES.count() == 0) {
    if (hefesto.project.toolset() == &quot;gcc-c-app&quot;) {
        $SOURCES.ls(&quot;.*\\.c@@bodyquot;);
    } else {
        $SOURCES.ls(&quot;.*\\.(cc|cpp|CC|Cpp|CPP)@@bodyquot;);
    }
}
</code></pre>">if ($SOURCES.count() == 0) {
    if (hefesto.project.toolset() == "gcc-c-app") {
        $SOURCES.ls(".*\\.c$");
    } else {
        $SOURCES.ls(".*\\.(cc|cpp|CC|Cpp|CPP)$");
    }
}
</code></pre><p>Se for passada uma lista de códigos vazia, ele escaneia o diretório corrente por códigos <em>C</em> ou <em>CC</em>. Pelo fato da mesma função de forja ser usada por outro <code>toolset</code> (<code>gcc-cc-app</code>) responsável por criar aplicativos <em>C++</em>, verificamos o nome do <code>toolset</code> atualmente carregado, via o subsistema <code>project</code>, se for “gcc-c-app” listamos todos os arquivos que terminem com “.c” no nome para dentro da lista <code>SOURCES</code>. Caso contrário, buscamos por códigos <em>C++</em>.</p><p>Se mesmo assim <code>SOURCES</code> estiver vazia:</p><pre><code data-origin="<pre><code>if ($SOURCES.count() == 0) {
    hefesto.sys.echo(&quot;\t(empty source list)\n&quot;);
    result 1;
}
</code></pre>">if ($SOURCES.count() == 0) {
    hefesto.sys.echo("\t(empty source list)\n");
    result 1;
}
</code></pre><p>Terminamos aqui, alertando sobre a lista vazia e saindo com <code>1</code> para sinalizar erro e fazer com que o <code>Hefesto</code> quebre o processo de forja para que o usuário tome conhecimento que algo deu errado.</p><p>Mais algumas conveniências… às vezes por motivos de higiene não desejamos poluir o diretório de onde o <em>build</em> roda com arquivos objeto:</p><pre><code data-origin="<pre><code>var obj_output_dir type list;
var obj_dir type string;

$obj_output_dir = hefesto.sys.get_option(&quot;obj-output-dir&quot;);
if ($obj_output_dir.count() &amp;gt; 0) {
    $obj_dir = $obj_output_dir.item(0);
    mktree($obj_dir);
} else {
    $obj_dir = hefesto.sys.pwd();
}
</code></pre>">var obj_output_dir type list;
var obj_dir type string;

$obj_output_dir = hefesto.sys.get_option("obj-output-dir");
if ($obj_output_dir.count() &gt; 0) {
    $obj_dir = $obj_output_dir.item(0);
    mktree($obj_dir);
} else {
    $obj_dir = hefesto.sys.pwd();
}
</code></pre><p>Nisso, verificamos se o usuário passou a opção <code>--obj-output-dir</code>. Lembrando que a <code>syscall get_option</code> retorna uma lista. Se a lista retornada contiver pelo menos um item é porque algo foi realmente passado e neste caso pegamos o primeiro item da lista (que é um <em>path</em>, <em>full</em> ou relativo) e passamos para a função <code>mktree()</code>, definida em <code>fsutil.hsl</code>. Essa função cria um <code>path</code> caso esse não exista. Agora, se não foi passada a opção <code>--obj-output-dir</code>, o diretório corrente é assumido como o <em>output-dir</em> para os arquivos objeto, <code>hefesto.sys.pwd()</code> nos garante isso.</p><p>Algo similar é feito com o diretório de saída para o binário que será criado com a forja, confira:</p><pre><code data-origin="<pre><code>$bin_output_dir = hefesto.sys.get_option(&quot;bin-output-dir&quot;);
if ($bin_output_dir.count() &amp;gt; 0) {
    $bin_output = $bin_output_dir.item(0);
    mktree($bin_output);
    $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
} else {
    $bin_output = $APPNAME;
}
</code></pre>">$bin_output_dir = hefesto.sys.get_option("bin-output-dir");
if ($bin_output_dir.count() &gt; 0) {
    $bin_output = $bin_output_dir.item(0);
    mktree($bin_output);
    $bin_output = hefesto.sys.make_path($bin_output, $APPNAME);
} else {
    $bin_output = $APPNAME;
}
</code></pre><p>Agora é chegada a hora de converter as opções do compilador em lista para <em>string</em>:</p><pre><code data-origin="<pre><code>    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES);
    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options
</code></pre>">    #  GCC's include list option string
    $includes = gcc_mk_gcc_incl_str_opt($INCLUDES);
    $cflags = gcc_mk_raw_str_opt($CFLAGS); #  GCC's compile options
</code></pre><p>Essas funções serão detalhadas mais tarde, por hora, só é importante conhecê-las superficialmente.</p><p>Também convém poder escolher a arquitetura do <em>target</em>, no caso a leitura de opção que será apresentada permite escolher entre um binário <em>32-bit</em> ou <em>64-bit</em>, confira:</p><pre><code data-origin="<pre><code>var cpu_arch type list;
var chosen_arch type string;
$cpu_arch = hefesto.sys.get_option(&quot;cpu-arch&quot;);
$chosen_arch = &quot;&quot;;
if ($cpu_arch.count() &amp;gt; 0) {
    $chosen_arch = $cpu_arch.item(0);
    if ($chosen_arch != &quot;32&quot; &amp;amp;&amp;amp; $chosen_arch != &quot;64&quot;) {
        hefesto.sys.echo(hefesto.project.toolset() +
                &quot; fatal error: invalid value for cpu-arch &quot; +
                &quot;option must be '32' or '64'.\n&quot;);
        result 1;
    }
}
</code></pre>">var cpu_arch type list;
var chosen_arch type string;
$cpu_arch = hefesto.sys.get_option("cpu-arch");
$chosen_arch = "";
if ($cpu_arch.count() &gt; 0) {
    $chosen_arch = $cpu_arch.item(0);
    if ($chosen_arch != "32" &amp;&amp; $chosen_arch != "64") {
        hefesto.sys.echo(hefesto.project.toolset() +
                " fatal error: invalid value for cpu-arch " +
                "option must be '32' or '64'.\n");
        result 1;
    }
}
</code></pre><p>Se o usuário passar <code>--cpu-arch=32</code> ou <code>--cpu-arch=64</code>, será adicionada a opção <code>-m32</code> ou <code>-m64</code> na linha de comando que será diretamente repassada ao <em>GCC</em>:</p><pre><code data-origin="<pre><code>$cflags = $cflags + &quot; -m&quot; + $chosen_arch;
</code></pre>">$cflags = $cflags + " -m" + $chosen_arch;
</code></pre><p>Essa opção do <em>GCC</em> especifica a arquitetura do <em>target</em>. Caso seja passado um valor diferente de <code>32</code> ou <code>64</code>, a forja será interrompida retornando <code>1</code> que significa erro.</p><p>Agora entregamos o controle para a função que propriamente compilará cada código presente no projeto:</p><pre><code data-origin="<pre><code>#  compiling...
hefesto.sys.echo(&quot;*** compiling...\n&quot;);

$exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
</code></pre>">#  compiling...
hefesto.sys.echo("*** compiling...\n");

$exit_code = gcc_compile_source_list($SOURCES, $includes, $cflags, $obj_dir); 
</code></pre><p>Mais para frente a função <code>gcc_compile_source_list()</code>, será detalhada.</p><p>Nesse <code>toolset</code> existe uma variável global chamada <code>gcc_c_project_forge_dirty_files_nr</code>, que guarda a contagem de arquivos efetivamente processados. Se após o final da compilação não houver nenhum arquivo processado, é feita a verificação se o <em>target</em> (o binário propriamente dito) existe. Caso não exista, a variável global de contagem é setada para <code>1</code>.</p><pre><code data-origin="<pre><code>if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;amp;&amp;amp; isfile($bin_output) == 0) {
    $gcc_c_project_forge_dirty_files_nr = 1;
}
</code></pre>">if ($gcc_c_project_forge_dirty_files_nr == 0 &amp;&amp; isfile($bin_output) == 0) {
    $gcc_c_project_forge_dirty_files_nr = 1;
}
</code></pre><p>O motivo de setar essa variável é por conta de garantir que a <em>linkedição</em> será feita (mesmo sem nenhum arquivo processado, porém sem o binário devemos <em>linkeditar</em>):</p><pre><code data-origin="<pre><code>if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0 &amp;amp;&amp;amp; $exit_code == 0) {
    $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
    $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
    if ($chosen_arch.len() &amp;gt; 0) {
        $ldflags = $ldflags + &quot;-m&quot; + $chosen_arch;
    }
    $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
    #  linking...
    hefesto.sys.echo(&quot;*** now linking...\n\t*** waiting...\n&quot;);
    $exit_code = gcc_link_ofiles($objects,
                                 $libraries
                                 $ldflags,
                                 $bin_output);
}
</code></pre>">if ($gcc_c_project_forge_dirty_files_nr &gt; 0 &amp;&amp; $exit_code == 0) {
    $objects = gcc_mk_ofiles_str_opt($SOURCES, $obj_dir);
    $ldflags = gcc_mk_raw_str_opt($LDFLAGS);
    if ($chosen_arch.len() &gt; 0) {
        $ldflags = $ldflags + "-m" + $chosen_arch;
    }
    $libraries = gcc_mk_gcc_lib_str_opt($LIBRARIES);
    #  linking...
    hefesto.sys.echo("*** now linking...\n\t*** waiting...\n");
    $exit_code = gcc_link_ofiles($objects,
                                 $libraries
                                 $ldflags,
                                 $bin_output);
}
</code></pre><p>Note que além da contagem de arquivos processados, a <em>linkedição</em> também depende de não ter havido nenhum erro na compilação, o <code>$exit_code == 0</code> na <code>if-clause</code> nos  garante isso.</p><p>Se necessário <em>linkeditar</em>:</p><ul>
<li>Os <em>file paths</em> correspondentes aos arquivos objeto são reunidos numa <em>string</em>;</li><li>O mesmo é feito com as opções de <em>linker</em> passadas pelo usuário, na declaração do projeto de forja;</li><li>Se a arquitetura foi explicitada adiciona a opção <em>GCC</em> correspondente nas opções de <em>linker</em>;</li><li>Deserializa também os file paths adicionais onde podem ser encontradas bibliotecas (isso foi passado pelo usuário na declaração do projeto de forja);</li><li>Chama a função que realiza efetivamente a <em>linkedição</em>: <code>gcc_link_ofiles()</code>.</li></ul><p>Depois apenas um relatório de <em>status</em> baseado no <em>exit code</em>, para orientar o usuário:</p><pre><code data-origin="<pre><code>if ($exit_code == 0) {
    hefesto.sys.echo(&quot;*** success.\n&quot;);
} else {
    hefesto.sys.echo(&quot;*** failure.\n&quot;);
}
</code></pre>">if ($exit_code == 0) {
    hefesto.sys.echo("*** success.\n");
} else {
    hefesto.sys.echo("*** failure.\n");
}
</code></pre><p>E por fim o retorno do exit code, o que é importante para que o <code>Hefesto</code> saiba que rumo a forja teve:</p><pre><code data-origin="<pre><code>result $exit_code;
</code></pre>">result $exit_code;
</code></pre><p>Volte na listagem integral do <code>source-code</code> da função de forja e veja se consegue entender cada porção de código dela. É importante para prosseguir entender realmente tudo que está sendo feito.</p><h5 id="detalhando-cada-forge-helper"><a name="detalhando-cada-forge-helper" href="#detalhando-cada-forge-helper"></a>Detalhando cada forge helper</h5><p>Anteriormente foi detalhada a função de forja, contudo, ela usa um conjunto de funções de apoio, as quais aqui serão melhor detalhadas.</p><h6 id="gcc_compile_source_list()"><a name="gcc_compile_source_list()" href="#gcc_compile_source_list()"></a>gcc_compile_source_list()</h6><p>Das ajudantes de forja, talvez a mais “complexa”. Por isso, vamos começar com ela.</p><p>Nessa função você verá como as alterações dos arquivos são monitoradas e que é de responsabilidade do desenvolvedor do <code>toolset</code> manter a sanidade dessa <code>feature</code>.</p><p>Existem dois <em>branches</em> de execução, um recai sobre a compilação <ins>síncrona</ins> o outro sobre a compilação <ins>assíncrona</ins>. Poderiam ter sido quebradas em duas funções, nada impede, mas aqui estão bifurcadas em <em>if-branches</em>.</p><p>Uma compilação <strong>síncrona</strong> pode ser entendida como <strong>uma compilação de arquivo por ciclo</strong>. Já uma compilação <strong>assíncrona</strong> pode ser entendida como <strong><em>n</em> compilações de arquivos por ciclo</strong>.</p><p>Essa é a definição da função:</p><pre><code data-origin="<pre><code>function gcc_compile_source_list(sources type list,
                                 includes type string,
                                 cflags type string,
                                 obj_dir type string) : result type int
</code></pre>">function gcc_compile_source_list(sources type list,
                                 includes type string,
                                 cflags type string,
                                 obj_dir type string) : result type int
</code></pre><p>Recebe a lista de códigos que serão compilados, uma <code>string</code> de diretórios de <em>includes</em>, uma <code>string</code> com opções que deverão ser usadas na compilação de cada código-fonte e o <em>path</em> para o diretório onde os arquivos objeto deverão ser gerados. Retorna zero para processamento sem erro e diferente de zero caso alguma coisa não ocorra conforme esperado.</p><p>O início da função é esse:</p><pre><code data-origin="<pre><code>var size type int;
var i type int;
var j type int;
var exit_code type int;
var ofile type string;
var qsize_list type list;
var run_list type list;
var qsize type int;
var not_compiled type list;
var not_compiled_tmp type list;
var compile_model type list;
var is_release type int;
var curr_src_file type string;

$size = $sources.count();

if ($size == 0) result 0;

$qsize_list = hefesto.sys.get_option(&quot;qsize&quot;);

if ($qsize_list.count() &amp;gt; 0) {
    $qsize = $qsize_list.item(0);
}
</code></pre>">var size type int;
var i type int;
var j type int;
var exit_code type int;
var ofile type string;
var qsize_list type list;
var run_list type list;
var qsize type int;
var not_compiled type list;
var not_compiled_tmp type list;
var compile_model type list;
var is_release type int;
var curr_src_file type string;

$size = $sources.count();

if ($size == 0) result 0;

$qsize_list = hefesto.sys.get_option("qsize");

if ($qsize_list.count() &gt; 0) {
    $qsize = $qsize_list.item(0);
}
</code></pre><p>Se passado uma lista de códigos vazia retorna zero logo de cara. Após isso é feita a leitura de uma opção reconhecida internamente pelo <em>Hefesto</em> que é a <code>--qsize=n</code>.</p><p>Essa opção indica o total de processos concorrentes que a <code>syscall run</code> é capaz de criar por chamada assíncrona. Para chamar a <code>run</code> de forma assíncrona é preciso passar uma lista de comandos.</p><p>Se a opção <code>--qsize</code> for passada, a função guarda o valor passado nela para uso posterior. Logo depois:</p><pre><code data-origin="<pre><code>$compile_model = hefesto.sys.get_option(&quot;compile-model&quot;);

$is_release = 1;

if ($compile_model.count() &amp;gt; 0) {
    if ($compile_model.item(0) != &quot;release&quot; &amp;amp;&amp;amp;
        $compile_model.item(0) != &quot;debug&quot;) {
        hefesto.sys.echo(hefesto.project.toolset() +
            &quot; internal error: unknown compile model: \&quot;&quot; +
            $compile_model.item(0) + &quot;\&quot;\n&quot;);
        result 1;
    }
    $is_release = ($compile_model.item(0) == &quot;release&quot;);
}
</code></pre>">$compile_model = hefesto.sys.get_option("compile-model");

$is_release = 1;

if ($compile_model.count() &gt; 0) {
    if ($compile_model.item(0) != "release" &amp;&amp;
        $compile_model.item(0) != "debug") {
        hefesto.sys.echo(hefesto.project.toolset() +
            " internal error: unknown compile model: \"" +
            $compile_model.item(0) + "\"\n");
        result 1;
    }
    $is_release = ($compile_model.item(0) == "release");
}
</code></pre><p>…Lemos a opção <code>compile-model</code>, se o usuário passou essa opção verifica se é <strong>release</strong> ou <strong>debug</strong>, sendo outro conteúdo quebra a forja saindo com <em>1</em>. Caso seja um dos dois valores reconhecidos, seta uma <em>flag</em> indicando a escolha, para uso posterior.</p><p>Agora vem a compilação propriamente dita:</p><pre><code data-origin="<pre><code>$exit_code = 0;
$i = 0;

$gcc_c_project_forge_dirty_files_nr = 0;

$not_compiled = lsdup($sources);

if ($qsize &amp;lt;= 1) {
    while ($i &amp;lt; $size &amp;amp;&amp;amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) +
                        &quot;: no errors found.\n&quot;);
            } else {
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) + &quot;: errors found!\n&quot;);
            }
        } else {
            hefesto.sys.echo(&quot;\t*** &quot; + $sources.item($i) + &quot;: no changes.\n&quot;);
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
} else {
    (...)
}
</code></pre>">$exit_code = 0;
$i = 0;

$gcc_c_project_forge_dirty_files_nr = 0;

$not_compiled = lsdup($sources);

if ($qsize &lt;= 1) {
    while ($i &lt; $size &amp;&amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) +
                        ": no errors found.\n");
            } else {
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) + ": errors found!\n");
            }
        } else {
            hefesto.sys.echo("\t*** " + $sources.item($i) + ": no changes.\n");
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
} else {
    (...)
}
</code></pre><p>O <em>else</em> refere-se a parte assíncrona, por hora vamos abstraí-la e nos atermos a parte síncrona. Temos a seguinte inicialização:</p><pre><code data-origin="<pre><code>$exit_code = 0;
$i = 0;
$gcc_c_project_forge_dirty_files_nr = 0;
$not_compiled = lsdup($sources);
</code></pre>">$exit_code = 0;
$i = 0;
$gcc_c_project_forge_dirty_files_nr = 0;
$not_compiled = lsdup($sources);
</code></pre><p>A variável que guarda o <em>exit code</em> das compilações é zerada. O contador que percorrerá a lista de códigos “começará pelo começo”. A <em>flag</em> que indica que algum arquivo foi efetivamente processado é <em>unsetada</em>. Depois usamos uma função presente em <code>lsutil.hsl</code>. Essa função retorna uma cópia da lista passada para ela.</p><p>A lista <code>not_compiled</code> tem uma utilidade especial. É por meio dela que o <em>Hefesto</em> conseguirá saber qual arquivo realmente mudou entre a última forja e a atual.</p><p>Existem duas funções <em>built-in</em> no <code>subsystem toolset</code>:</p><ul>
<li><code>hefesto.toolset.file_has_change(&lt;file-path&gt;)</code></li><li><code>hefesto.toolset.base_refresh(&lt;untouched-files&gt;)</code></li></ul><p>A <code>file_has_change</code> é bem direta:</p><blockquote>
<p>Recebe o <em>path</em> de um arquivo e retorna <strong>1</strong> caso esse <strong>arquivo tenha mudado</strong>, de outra forma <strong>0</strong>.</p>
</blockquote><p>Já <code>base_refresh()</code>:</p><blockquote>
<p>Recebe uma lista de <em>paths</em>, mas essa lista deve apenas conter os <em>paths</em> dos arquivos que <strong>ainda não foram processados</strong>.</p>
</blockquote><p>O <em>workflow</em> de uso dessas funções geralmente se resume em invocar <code>file_has_change</code> para saber se o arquivo corrente mudou, se mudou, se aplica o processamento necessário. Realiza isso para cada arquivo. Ao final, chama apenas uma única vez a <code>base_refresh</code>. Com essas duas <code>toolset-functions</code> o <em>Hefesto</em> é capaz de saber exatamente quem mudou desde a última forja.</p><p>Voltemos ao código:</p><pre><code data-origin="<pre><code>if ($qsize &amp;lt;= 1) {
    while ($i &amp;lt; $size &amp;amp;&amp;amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) +
                        &quot;: no errors found.\n&quot;);
            } else {
                hefesto.sys.echo(&quot;\t*** &quot; +
                        $sources.item($i) + &quot;: errors found!\n&quot;);
            }
        } else {
            hefesto.sys.echo(&quot;\t*** &quot; + $sources.item($i) + &quot;: no changes.\n&quot;);
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &amp;gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
}
</code></pre>">if ($qsize &lt;= 1) {
    while ($i &lt; $size &amp;&amp; $exit_code == 0) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $exit_code =
                hefesto.sys.run(
                  gcc_mk_app_compilation_command($curr_src_file,
                                                 $ofile,
                                                 $includes,
                                                 $cflags, $is_release
                  )
                );
            if ($exit_code == 0) {
                $not_compiled.del_item($sources.item($i));
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) +
                        ": no errors found.\n");
            } else {
                hefesto.sys.echo("\t*** " +
                        $sources.item($i) + ": errors found!\n");
            }
        } else {
            hefesto.sys.echo("\t*** " + $sources.item($i) + ": no changes.\n");
        }
        $i = $i + 1;
    }
    if ($gcc_c_project_forge_dirty_files_nr &gt; 0) {
        hefesto.toolset.base_refresh($not_compiled);
    }
}
</code></pre><p>Se a forja tiver que ser síncrona, i.e: se <code>qsize</code> for igual ou menor a <em>1</em>, para cada caminho de arquivo (código <em>C</em>) presente na lista, enquanto não houver nenhum erro de compilação:</p><blockquote>
<p>À partir do path do arquivo usamos a função <code>gcc_mk_ofile_name()</code> para criar o nome objeto do arquivo, de fato apenas substituímos o <code>.c</code> por <code>.o</code> e juntamos esse novo nome com o conteúdo do caminho para o diretório de arquivos objeto.</p>
<p>Verificamos se o arquivo <code>.c</code> teve alteração ou se seu arquivo objeto não existe.</p>
<blockquote>
<p>Com uma dessas duas condições satisfeitas, incrementamos o contador de arquivos processados e rodamos o comando de compilação. Se o arquivo for compilado com êxito, removemos o <em>path</em> dele da lista <code>not_compiled</code>.</p>
<p>Se o arquivo <code>.c</code> não mudou e o seu objeto existe, apenas informa que não houveram mudanças naquele arquivo.</p>
</blockquote>
</blockquote><p>Após todos os códigos-fonte processados, se houve efetivamente pelo menos uma compilação, realiza o <code>base-refresh</code> e retorna o <em>exit code</em> do processo, para que o chamador tome a medida necessária baseada nesse valor retornado.</p><p>Agora vamos ver a parte assíncrona da compilação:</p><pre><code data-origin="<pre><code>else {
    $not_compiled_tmp.clear();
    while ($i &amp;lt; $size) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $run_list.add_item(
                gcc_mk_app_compilation_command($curr_src_file,
                                               $ofile,
                                               $includes,
                                               $cflags,
                                               $is_release));
            $not_compiled_tmp.add_item($sources.item($i));
        }
        if ($run_list.count() == $qsize) {
            $exit_code = hefesto.sys.run($run_list);
            if ($exit_code == 0) {
                $j = 0;
                while ($j &amp;lt; $not_compiled_tmp.count()) {
                    $not_compiled.del_item($not_compiled_tmp.item($j));
                    $j = $j + 1;
                }
                $not_compiled_tmp.clear();
                hefesto.toolset.base_refresh($not_compiled);
            }
            $run_list.clear();
        }
        $i = $i + 1;
    }
    if($run_list.count() &amp;gt; 0) {
        $exit_code = hefesto.sys.run($run_list);
        if ($exit_code == 0) {
            $j = 0;
            while ($j &amp;lt; $not_compiled_tmp.count()) {
                $not_compiled.del_item($not_compiled_tmp.item($j));
                $j = $j + 1;
            }
            hefesto.toolset.base_refresh($not_compiled);
        }
    }
}
</code></pre>">else {
    $not_compiled_tmp.clear();
    while ($i &lt; $size) {
        $ofile = $sources.item($i);
        $ofile = gcc_mk_ofile_name(filenamefrompath($ofile), $obj_dir);
        if (hefesto.toolset.file_has_change($sources.item($i)) == 1 ||
            isfile($ofile) == 0) {
            $gcc_c_project_forge_dirty_files_nr =
                $gcc_c_project_forge_dirty_files_nr + 1;
            $curr_src_file = $sources.item($i);
            $run_list.add_item(
                gcc_mk_app_compilation_command($curr_src_file,
                                               $ofile,
                                               $includes,
                                               $cflags,
                                               $is_release));
            $not_compiled_tmp.add_item($sources.item($i));
        }
        if ($run_list.count() == $qsize) {
            $exit_code = hefesto.sys.run($run_list);
            if ($exit_code == 0) {
                $j = 0;
                while ($j &lt; $not_compiled_tmp.count()) {
                    $not_compiled.del_item($not_compiled_tmp.item($j));
                    $j = $j + 1;
                }
                $not_compiled_tmp.clear();
                hefesto.toolset.base_refresh($not_compiled);
            }
            $run_list.clear();
        }
        $i = $i + 1;
    }
    if($run_list.count() &gt; 0) {
        $exit_code = hefesto.sys.run($run_list);
        if ($exit_code == 0) {
            $j = 0;
            while ($j &lt; $not_compiled_tmp.count()) {
                $not_compiled.del_item($not_compiled_tmp.item($j));
                $j = $j + 1;
            }
            hefesto.toolset.base_refresh($not_compiled);
        }
    }
}
</code></pre><p>O comportamento é similar ao da porção síncrona. Uma diferença é que os comandos de compilação não são imediatamente executados, sendo eles adicionados a uma lista para execução ao final de um ciclo. Outra diferença é que aqui há uma lista auxiliar chamada <code>not_compiled_tmp</code> que é preenchida por ciclos e o <code>base-refreh</code> é feito ao final desses ciclos. Um ciclo é completo quando o tamanho de <code>run_list</code>, que é a lista que contém os comandos de compilação ainda não executados, contiver o total de elementos igual a <code>--qsize</code>. Se alguma compilação quebrar ao final de um ciclo, o <em>loop</em> será interrompido. Se ao final do <em>loop</em> não havendo erro de compilação, ainda houverem códigos por compilar, eles serão compilados e o <code>base-refresh</code> feito.</p><h6 id="gcc_mk_app_compilation_command()"><a name="gcc_mk_app_compilation_command()" href="#gcc_mk_app_compilation_command()"></a>gcc_mk_app_compilation_command()</h6><p>Essa função é responsável por <strong>montar</strong> os comandos de compilação que serão executados:</p><pre><code data-origin="<pre><code>local function gcc_mk_app_compilation_command(src_name type string,
                                              outfile type string,
                                              includes type string,
                                              cflags type string,
                        is_release type int) : result type string {
    var cmd type string;
    if ($is_release == 1) {
        $cmd = hefesto.toolset.compile_r($src_name, $outfile, $includes, $cflags);
    } else {
        $cmd = hefesto.toolset.compile_d($src_name, $outfile, $includes, $cflags);
    }
    result $cmd;
}
</code></pre>">local function gcc_mk_app_compilation_command(src_name type string,
                                              outfile type string,
                                              includes type string,
                                              cflags type string,
                        is_release type int) : result type string {
    var cmd type string;
    if ($is_release == 1) {
        $cmd = hefesto.toolset.compile_r($src_name, $outfile, $includes, $cflags);
    } else {
        $cmd = hefesto.toolset.compile_d($src_name, $outfile, $includes, $cflags);
    }
    result $cmd;
}
</code></pre><p>Note que são passados para ela todos os parâmetros necessários para se compilar um fonte no <em>GCC</em> com a opção <code>-c</code> (confira o <em>template</em> dos comandos <code>compile_r</code> e <code>compile_d</code> na declaração do <code>toolset</code>). Note que fora isso, é também informado o tipo de compilação, se é desejado incluir informações de <em>debug</em> ou não (em <em>release</em> não incluirá). Logo após, apenas é retornado a linha de comando formatada, pois um <code>toolset-command</code> não é executado, cabe ao desevolvedor do <code>toolset</code> escolher a melhor maneira de executá-lo via a <code>syscall run</code> e avaliar o <em>exit code</em> de tal comando. Lembrando que todos os <code>toolset-commands</code> estão disponíveis para a função de forja e suas ajudantes à partir do subsistema <code>toolset</code> (<code>hefesto.toolset.&lt;command&gt;</code>). Ainda, tudo o que foi passado para o comando se resumiu em argumentos do tipo <code>string</code>. Se existir um lema para um <code>toolset-command</code>, pode ser esse:</p><blockquote>
<p>Somente recebe <em>strings</em> <strong>na ordem e quantidade</strong> pré-definidas, somente retorna <strong>uma</strong> <em>string</em>.</p>
</blockquote><h6 id="gcc_link_ofiles()"><a name="gcc_link_ofiles()" href="#gcc_link_ofiles()"></a>gcc_link_ofiles()</h6><p>Essa função é responsável por <em>linkeditar</em> os arquivos objeto produzindo a aplicação sob o nome que <code>appname</code> contiver.</p><p>Note que o argumento <code>objects</code> já é a lista de objetos no formato <em>string</em> que o <em>GCC</em> espera, i.e: <em>“foo.o bar.o baz.o”</em>.</p><p>As variáveis <code>libraries</code> e <code>ldflags</code> a mesma coisa, listas no formato <em>string</em> que o <em>GCC</em> espera.</p><p>Lembre que na função de forja nos ocupamos de converter as listas <code>HSL</code> passadas pelo usuário do <code>toolset</code> para o “formato <em>string</em> do <em>GCC</em>“.</p><p>A primeira coisa que essa função de <em>linking</em> faz é verificar se a opção <code>--link-model</code> foi passada pelo usuário. Essa opção admite dois modos de <em>linking</em>: <code>static</code> ou <code>shared</code>. Se for passado um modo de <em>linkagem</em> alienígena a forja quebrará com saída <em>1</em>.</p><p>Se um dos modos reconhecidos foi passado (note que o modo padrão é <em>shared</em>), essa função monta o comando de <em>linking</em> necessário à partir do <code>command-template</code> correspondente, definido no <code>toolset</code> e o executa com a <code>syscall run</code>. Retornando ao final o <code>exit code</code> do processo de <em>linkedição</em>.</p><p>Confira a listagem do código e repasse o que leu:</p><pre><code data-origin="<pre><code>function gcc_link_ofiles(objects type string,
                         libraries type string,
                         ldflags type string,
                         appname type string) : result type int {
    var exit_code type int;
    var link_model type list;
    var is_static type int;
    $link_model = hefesto.sys.get_option(&quot;link-model&quot;);
    $is_static = 0;
    if ($link_model.count() &amp;gt; 0) {
        if ($link_model.item(0) == &quot;static&quot;) {
            $is_static = 1;
        } else {
            if ($link_model.item(0) != &quot;shared&quot;) {
                hefesto.sys.echo(hefesto.project.toolset() +
                        &quot; internal error: unknown link model: \&quot;&quot; +
                        $link_model.item(0) + &quot;\&quot;\n&quot;);
                result 1;
            }
        }
    }
    if ($is_static == 1) {
        $exit_code = hefesto.sys.run(
            hefesto.toolset.link_static($appname,
                                        $objects,
                                        $libraries, $ldflags));
    } else {
        $exit_code = hefesto.sys.run(
           hefesto.toolset.link_shared($appname,
                                    $objects,
                                    $libraries, $ldflags));
    }
    result $exit_code;
}
</code></pre>">function gcc_link_ofiles(objects type string,
                         libraries type string,
                         ldflags type string,
                         appname type string) : result type int {
    var exit_code type int;
    var link_model type list;
    var is_static type int;
    $link_model = hefesto.sys.get_option("link-model");
    $is_static = 0;
    if ($link_model.count() &gt; 0) {
        if ($link_model.item(0) == "static") {
            $is_static = 1;
        } else {
            if ($link_model.item(0) != "shared") {
                hefesto.sys.echo(hefesto.project.toolset() +
                        " internal error: unknown link model: \"" +
                        $link_model.item(0) + "\"\n");
                result 1;
            }
        }
    }
    if ($is_static == 1) {
        $exit_code = hefesto.sys.run(
            hefesto.toolset.link_static($appname,
                                        $objects,
                                        $libraries, $ldflags));
    } else {
        $exit_code = hefesto.sys.run(
           hefesto.toolset.link_shared($appname,
                                    $objects,
                                    $libraries, $ldflags));
    }
    result $exit_code;
}
</code></pre><p>É isso, um bom exercício é tentar criar um <code>toolset</code> para automatizar algo para o seu estado de coisas. Não precisa pensar apenas em compiladores, você pode tentar criar um <code>toolset</code> que faça o <em>deploy</em> do seu pacote, entre outras coisas. Seja criativo(a)!</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
